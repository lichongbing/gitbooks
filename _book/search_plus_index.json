{"./":{"url":"./","title":"概述","keywords":"","body":"前言 本书是作者对Java知识生态圈的技术梳理，作者一边在学习并运用工作，一边更新整理。作者由零基础慢慢深入，由浅入深，逐步掌握把握Java知识生态圈，帮助Javaava初学者和爱好者，旨在帮助读者掌握Java基础知识、了解开发技巧并积累一定的项目实战经验。为什么要写这样一本书 荀子曰：“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” 反复实践，反复理解，反复总结，提升自我，帮助大家。2000多年前，孔夫子就曾说过，“学而时习之，不亦说乎？”杨伯峻先生在《论语译注》中对这句话有精辟的注解：“学了，然后（按一定的时间）去实习它，不也高兴吗？”对于Java的学习，也应是这样，仅仅懂得一堆Java语法，毫无意义，我们必须亲自动手实践它。 "},"java5.html":{"url":"java5.html","title":"Java基础","keywords":"","body":"Java基础 Java 开发环境搭建 过上一章的阅读，相信读者对Java语言已经有了大概的了解，本章更进一步地介绍如何在Windows操作系统中下载与安装JDK，并详细描述在Windows操作系统下开发环境的配置。最后介绍如何编译和运行第1个Java程序，再简要介绍在Eclipse环境下如何开发Java程序。 本章要点（已掌握的在方框中打钩） 掌握下载、安装Java开发工具箱 掌握开发环境变量的配置 学会编写第1个Java程序 学会在Eclipse下编写Java程序 1.1 Java开发环境 学习Java的第一步，自然就是要搭建Java开发环境（Java Development Kit，JDK），在操作系统（如Windows、Linux等）下，JDK是搭建Java最基本的开发环境之一，目前由Oracle公司维护开发并免费提供。DK由一个处于操作系统层之上的开发环境和运行环境组成，如下图所示。JDK除了包括编译（javac）、解释（java）、打包（jar）等工具，还包括开发工具及开发工具的应用程序接口等。当Java程序编译完毕后，如果想运行，还需要Java运行环境（Java Runtime Environment，JRE）。JRE是运行Java程序所必需的环境的集合，包含JVM标准实现及Java核心类库。如果仅仅想运行Java程序，安装JRE就够了。也就是说，JRE是面向Java程序的使用者的。但如果想进一步开发Java程序，那就需要安装JDK，它是面向Java程序的开发者的。Java程序的开发者自然也是Java程序的应用者。从下图也容易看出，JDK包含JRE。 由上图可以看出，Java程序开发的第一步就是编写Java语言的源代码。而编写源代码的工具，可以是任何文本编辑器，如Windows 操作系统下的记事本、Linux操作系统下的Vim等。这里推荐读者使用对编程语言支持较好的编辑器，如Notepad++、UltraEdit、Editplus等，这类代码编辑器通常有较好的语法高亮等特性，特别适合开发程序代码。Java源文件编写完毕后，就可以在命令行下，通过javac命令将Java源程序编译成字节码（Byte Code，Java虚拟机执行的一种二进制指令格式文件)，然后通过java命令，来解释执行编译好的Java类文件（文件扩展名为.class）。但如果想正确使用javac和java等命令，用户必须自己搭建Java开发环境。在后续章节，我们将详细介绍相关的配置步骤。为了提高Java的开发效率，目前在市面上也涌现了很多优秀的Java集成开发环境（Integrated Development Environment， IDE），如NetBeans（由Sun公司开发的老牌IDE）、IntelliJIDEA（由捷克软件公司JetBrains开发的智能IDE，需要付费使用）及Eclipse（免费开源的知名IDE）等。IDE在JDK的基础上，为程序提供了很多辅助功能的支持，极大方便了程序的开发。在本章最后部分，我们将简要地介绍最流行的 IDE之一——Eclipse的使用。 1.2 安装Java开发工具箱 Oracle公司提供多种操作系统下的不同版本的JDK。本节主要介绍在Windows操作系统下安装JDK的过程。 1.2.1 下载JDK 但需要提醒读者的是，对于软件开发而言，过度“最新”并非好事，如果你不是有特殊需求，Java 8足够用了。为什么说过度“最新”并非好事呢？这是因为Java 9和Java 10虽然有很多好的新特性，但它依附的生态还没有建立起来。比如说，如果你想学习基于Hadoop的大数据编程，很可能Hadoop的最新版还是由Java 8编译而成，你用Java 10编译出来的程序，难以在Hadoop上运行。所以对于学习编程软件，特别是初学者，我们的建议是保守的，暂时还采用业界广泛使用的Java来编程。事实上，Java 8、 Java 7甚至Java 6，仍在企业界有着广泛应用。作为初级用户，实在没有必要跟风，一定要下载最新的Java版本，因为很多新特性，初学者根本没有机会用到。或许Oracle公司也知Java 9和Java 10的更新幅度太大，而Java 8依然是业界开发的主流，于是，在Java 10 同一个下载网页的下方，Oracle给出了Java 8的下载界面，如下图所示。 "},"java.html":{"url":"java.html","title":"Java知识思维导图","keywords":"","body":"泛型类定义类型\\n * 方法：add、remove、indexof\\n * 数据类型的封箱和拆箱\\n * 因为我们的ArrayList里面数据类型只能承装引用类型：比如要承装int类型，就需要进行转换为Integer类\\n * 自动封箱int直接转换为Integer\\n * 自动拆箱Integer拆箱为int\\n * 11 字符串String\\n * 特殊的引用类型，在java.lang包下面的，不需要进行导入，本身也是一个对象。\\n * 关于字符串的内存分析：String字符串内存是在常量池中不断发生变化的\\n * 字符串的操作：toCharArray、getBytes、indexOf、split、replace\\n * 12 Static关键字\\n * static关键字的使用\\n * 静态关键字static可以修饰成员变量和成员方法以及可以修饰代码块(静态代码块)\\n * 加载时间：静态关键字修复的额任何内容都是和类一起进行加载的（优先级和类加载评级）\\n * 静态关键字修饰的成员变量和方法都可以直接通过：类名.静态变量 类名.静态方法\\n * 静态关键字是属于类的，他不属于某一个对象，但是一旦发生变化，全部都会发生变化\\n * 注意事项\\n * 静态方法不能直接访问普通成员变量或成员方法，只能访问静态所修饰的变量和方法\\n * 反之，普通的成员方法(未被static修饰的方法)可以直接访问类变量或静态方法\\n * 静态方法中，不能使用this关键字\\n * 13 Java的数据类型\\n * java的基础数据类型\\n * 整型\\n * byte\\n * short\\n * int默认的整数类型\\n * long\\n * 浮点型\\n * float(3.14F)\\n * double（默认）\\n * 字符型\\n * char\\n * ASC码表\\n * '0'字符数值为48\\n * 'A'字符数值为65\\n * 'a'字符数值为97\\n * 布尔型\\n\\n\\n\\n\\n\\n```\\n\",\"args\":[],\"kwargs\":{},\"blocks\":[]}\" data-svg-text=\"\"* Java基础-入门篇知识点总结\\n * 数组\\n * 数组：一种容器\\n * 数组的创建\\n * int[] arr = new int[10]\\n * int[] arr = new int []{1,2,3,4,5}\\n * int[] arr = {1,2,3,4,5}\\n * 数组的访问\\n * 索引：从下标0开始的，数组的总长度：数组.length（）\\n * 内存分析\\n * 寄存器\\n * 本地方法栈\\n * 方法区:存放.class文件\\n * 堆内存：java里面所有使用new关键字创建的对象都是存放在堆内存中\\n * 栈：声明的变量都市在栈上去声明的\\n * 关于值传递与引用传递\\n * 值传递：基础数据类型都是值传递\\n * 引用数据类型：都是地址传递 如数组arr\\n * 面向对象的思想\\n * 万事万物皆对象\\n * 面向对象(类和实例的关系) \\n * 类是抽象的，对象是具体的；类相当于一个模板，对象是通过类进行创建的，并且类和对象之间为1对多的关系\\n \\n * 类的详细使用\\n * 成员变量\\n * 成员方法\\n * 构造器\\n * java中默认为每一个类提供默认的无参数的构造器\\n * 也可以定义很多有参数的构造器（方法的重载）\\n * 一个标准的javabean封装\\n * 1 要对成员变量添加private修饰符，表示私有的，其他的外部无法之间访问\\n * 2 必须要自己是想getXXX和setXXX来进行访问看，安全性\\n * 3 java里面默认会为每一个类提供无参的构造器，也可以自己定义有参的构造器\\n * 4 this关键字的作用；永远指代当前的对象(当前实例化的对象)\\n * 10 API的使用\\n * API:应用程序提供访问的接口\\n * 包package：合理划分我们的代码，使我们的代码结构更加清晰\\n * Scanner 扫描类\\n * Random随机类\\n * ArrayList容器类\\n * 基于数组去实现的，并且长度不做限制，ArrayList也只能承装一类数据类型(只能是引用类型)，使用泛型类定义类型\\n * 方法：add、remove、indexof\\n * 数据类型的封箱和拆箱\\n * 因为我们的ArrayList里面数据类型只能承装引用类型：比如要承装int类型，就需要进行转换为Integer类\\n * 自动封箱int直接转换为Integer\\n * 自动拆箱Integer拆箱为int\\n * 11 字符串String\\n * 特殊的引用类型，在java.lang包下面的，不需要进行导入，本身也是一个对象。\\n * 关于字符串的内存分析：String字符串内存是在常量池中不断发生变化的\\n * 字符串的操作：toCharArray、getBytes、indexOf、split、replace\\n * 12 Static关键字\\n * static关键字的使用\\n * 静态关键字static可以修饰成员变量和成员方法以及可以修饰代码块(静态代码块)\\n * 加载时间：静态关键字修复的额任何内容都是和类一起进行加载的（优先级和类加载评级）\\n * 静态关键字修饰的成员变量和方法都可以直接通过：类名.静态变量 类名.静态方法\\n * 静态关键字是属于类的，他不属于某一个对象，但是一旦发生变化，全部都会发生变化\\n * 注意事项\\n * 静态方法不能直接访问普通成员变量或成员方法，只能访问静态所修饰的变量和方法\\n * 反之，普通的成员方法(未被static修饰的方法)可以直接访问类变量或静态方法\\n * 静态方法中，不能使用this关键字\\n * 13 Java的数据类型\\n * java的基础数据类型\\n * 整型\\n * byte\\n * short\\n * int默认的整数类型\\n * long\\n * 浮点型\\n * float(3.14F)\\n * double（默认）\\n * 字符型\\n * char\\n * ASC码表\\n * '0'字符数值为48\\n * 'A'字符数值为65\\n * 'a'字符数值为97\\n * 布尔型\\n\\n\\n\\n\\n\\n\"\"> "},"java6.html":{"url":"java6.html","title":"Java程序要素概览","keywords":"","body":" 初识庐山真面目——Java程序要素概览 麻雀虽小，五脏俱全。本章的实例虽然非常简单，但基本涵盖了本篇所讲的内容。可以通过本章来了解Java程序的组成及内部部件（如Java中的标识符、关键字、变量、注释等）。同时，本章还涉及Java程序错误的检测及Java编程风格的注意事项。 本章要点（已掌握的在方框中打钩） 掌握Java程序的组成 掌握Java程序注释的使用 掌握Java中的标识符和关键字 了解Java中的变量及其设置 了解程序的检测 掌握提高程序可读性的方法 2.1 一个简单的例子 从本章开始，我们正式开启学习Java程序设计的旅程。在本章，除了认识程序的架构外，我们还将介绍标识符、关键字以及一些基本的数据类型。通过简单的范例，让读者了解检测与提高程序可读性的方法，以培养读者良好的编程风格和正确的程序编写习惯。 下面来看一个简单的Java程序。在介绍程序之前，读者先简单回顾一下第1章讲解的例子，之后再来看下面的这个程序，在此基础上理解此程序的主要功能。 /** * @ClassName: TestJava * @Description: 这是Java的一个简单范例 * @author: YuHong * @date: 2016年11月15日 */ public class TestJava { public static void main(String args[ ]) { int num ; // 声明一个整型变量num num = 5 ; // 将整型变量赋值为5 // 输出字符串，这里用“+” 号连接变量 System.out.println(\"这是数字 \" + num); System.out.println(\"我有 \" + num + \"本书！\"); } } "},"java7.html":{"url":"java7.html","title":"Java编程基础","keywords":"","body":"九层之台，起于垒土——Java编程基础 本章讲解Java中的基础语法，包括常量和变量的声明与应用、变量的命名规则、Java的基本数据类型和数据类型的转换等。本章内容是接下来章节的基础，初学者应该认真学习。 本章要点（已掌握的在方框中打钩） 掌握常量和变量的声明方法 掌握变量的命名规则 掌握变量的作用范围 掌握基本数据类型的使用 Java语言强大灵活，与C++语言语法有很多相似之处。但要想熟练使用Java语言，就必须从了解Java语言基础开始，就如同老子在《道德经》说的那样，“合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。” 南宋的史学家和文学家范晔在《后汉书·郭太传》中也有言，“墙高基下，虽得必失”，说的就是，高耸的大墙，其基础却十分低矮，这样的墙虽然建成了，但一定会倒塌。同样，想要学好Java，一定要打好坚实的基础，没有坚实的基础，很容易留下后患，比如成为制约变成Java高手的瓶颈。 在接下来的章节里，我们主要讨论Java的基础语法， "},"java8.html":{"url":"java8.html","title":"基础编程元素--运算符 表达式 语句与流程控制","keywords":"","body":"基础编程元素——运算符、表达式、语句与流程控制 运算符、表达式、语句与流程控制，是Java的基础编程元素，无论多复杂的编程框架和GUI，追根溯源，都是由这些基本元素构成的。本章介绍Java运算符的用法、表达式与运算符之间的关系以及程序的流程控制等。学完本章，读者能对Java语句的运作过程有更深一层的认识。 本章要点（已掌握的在方框中打钩） 掌握各种运算符的用法 掌握各种表达式的用法 掌握表达式与运算符的关系 ( 掌握程序结构的3种模式 4.1 运算符 设计程序的目的，简单来说，就是让机器实施运算，而程序语言中提供运算功能的就是运算符（operator）。在最底层，Java中的数据都是通过这些运算符来完成计算的。 "},"java9.html":{"url":"java9.html","title":"常用的数据结构--数组与枚举","keywords":"","body":"常用的数据结构——数组与枚举 数组与枚举是Java中一种常见的数据结构，分为一维数组、二维数组及多维数组等几种。只有灵活掌握数组与枚举的应用，才能编写出更强大、效率更高的Java程序。本章将介绍在Java中使用数组与枚举的相关知识，其包括数组的声明和定义、枚举的定义和使用等。 本章要点（已掌握的在方框中打钩） 掌握一维数组的使用 掌握二维数组的使用 了解数组越界的风险 熟悉多维数组的使用 掌握枚举的概念 熟悉枚举的作用5.1 理解数组 试想一下，如果编写一个程序，需要存储12个月份的天数，是否要定义12个变量呢？如果编写一个扑克程序，里面应该需要存储54张扑克的信息，是否要定义54个变量？而如果程序需要存储成千上万的数据，程序员是不是也要逐一定义成千上万个变量？如果这样做，一是工程量太大，二是这些逐一定义的变量之间彼此独立，没有任何内在联系，这会给维护这些变量带来巨大的困难，有时 "},"java10.html":{"url":"java10.html","title":"面向对象设计的核心--类与对象","keywords":"","body":"面向对象设计的核心——类和对象 类和对象是面向对象编程语言的重要概念。Java是一种面向对象的语言，所以要想熟练使用Java语言，就一定要掌握类和对象的使用。本章介绍面向对象基本的概念，面向对象的3个重要特征（封装性、继承性、多态性）以及声明创建类和对象（数组）的方法。 本章要点（已掌握的在方框中打钩） 了解类和对象的相关概念 掌握声明及创建类和对象的方法 掌握对象的比较方法 到目前为止，前面介绍的语法都属于编程语言的基本功能，其中包括数据类型和程序控制语句等。随着计算机的发展，面向对象的概念产生。类（class）和对象（object）是面向对象程序设计十分重要的概念。要深入了解Java程序语言，一定要树立面向对象程序设计的观念。从本章开始学习Java程序中类的设计及对象的使用。 6.1 理解面向对象程序设计 面向对象程序设计（Object Oriented Programming，OOP）是继面向过程又一具有里程碑意义的编程思想,是现实世界模型的自然延伸。下面从结构化程序设计说起，逐步展示面向对象程序设计。 "},"java11.html":{"url":"java11.html","title":"重复调用的代码块--方法","keywords":"","body":"重复调用的代码块——方法 在面向对象的程序设计中，方法是一个很重要的概念，体现了面向对象三大要素中“封装”的思想。“方法”又称为“函数”，在其他的编程语言中都有类似的概念，其重要性是不言而喻的。在本章读者将会学到如何定义和使用方法，以及学会使用方法的再一次抽象——代码块。除此之外，方法中对数组的应用也是本章讨论的重点。 本章要点（已掌握的在方框中打钩） 掌握方法的定义和使用 掌握构造方法的使用 掌握普通代码块、构造代码块、静态块的意义和基本使用 掌握在方法中对数组的操作 通过对前面章节的学习，读者应该了解，在本质上，一个类其实就描述了两件事情：① 一个对象知道什么（what's an object knows）？② 一个对象能做什么（what's an object does）？第①件事情，对应于对象的属性（或状态）；第②件事情对应于对象的行为（或方法）。下面用范例7-1来说明类的这两个层面。 "},"java12.html":{"url":"java12.html","title":"面向对象设计的精华--类的封装 继承 多态","keywords":"","body":"面向对象设计的精华——类的封装、继承与多态 类的封装、继承和多态是面向对象程序的三大特性。类的封装相当于一个黑匣子，放在黑匣子中的东西你什么也看不到。继承是类的另一个重要特性，可以从一个简单的类继承出相对复杂高级的类，通过代码重用，可使程序编写的工作量大大减轻。多态通过单一接口操作多种数据类型的对象，可动态地对对象进行调用，使对象之间变得相对独立。本章讲解类的三大特性：封装、继承和多态。 本章要点（已掌握的在方框中打钩） 掌握封装的基本概念和应用 掌握继承的基本概念和应用 掌握多态的基本概念和应用 掌握super关键字的使用熟悉对象的多态性 8.1 面向对象的三大特点 面向对象有三大特点：封装性、继承性和多态性，它们是面向对象程序设计的灵魂所在，下面一一给予讲解。 8.1.1 封装的含义 封装（encapsulation）是将描述某类事物的数据与处理这些数据的函数封装在一起，形成一个有机整体，称为类。类所具有的封装性可使程序模块具有良好的独立性与可维护性，这对大型程序的开发是特别重要的。 类中的私有数据在类的外部不能直接使用，外部只能通过类的公共接口方法（函数）来处理类中的数据，从而使数据的安全性得到保证。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，仅需要通过外部接口和特定的访问权限来使用类的成员。 一旦设计好类，就可以实例化该类的对象。我们在形成一个对象的同时，也界定了对象与外界的内外界限。至于对象的属性、行为等实现的细节则被封装在对象的内部。外部的使用者和其他的对象只能经由原先规划好的接口和对象交互。我们可用一个鸡蛋的三重构造来比拟一个对象，如下图所示。 属性好比蛋黄，它隐藏于中心，不能直接接触，它代表对象的状态（state）。 行为好比蛋白，它可以经由接口与外界交互而改变内部的属性值，并把这种改变通过接口呈现出来。 接口好比蛋壳，它可以与外界直接接触。 外部也只能通过公开的接口方法来改变对象内部的属性（数据）值，从而使类中数据的安全性得到保证。 8.1.2 继承的含义 对象（object）是类（class）的一个实例（instance）。如果将对象比作房子，那么类就是房子的设计图纸。所以面向对象设计的重点是类的设计，而不是对象的设计。继承性是面向对象的第二大特征。继承（inheritance）是面向对象程序设计中软件复用的关键技术，通过继承，可以进一步扩充新的特性，适应新的需求。这种可复用、可扩充技术在很大程度上降低了大型软件的开发难度，从而提高软件的开发效率。 中国古代逻辑学家公孙龙（约公元前320—公元前250年）提出了一个著名的逻辑问题：“白马非马”。在《公孙龙子 ● 白马论》中有这样的描述：“白马非马，可乎？”曰：“可。”曰：“何哉？”曰：“马者，所以命形也。白者，所以命色也。命色者，非命形也，故曰白马非马。” 在一定程度上，公孙龙的“白马非马”逻辑体现了面向对象“继承”思想。公孙龙声称：“白马不是马”，其论证过程如下。“马”只有一个特征：马的特征。而“白马”有两个特征：① 马的特征；② 白色的。因此，在逻辑上，拥有两个特征的“白马”不等同于只有一个特征的“马”，所以“白马非马”。而从集合论上来考虑，马与白马是两个不同的集合，但是“马”这个集合包含了另一个集合“白马”， 后者是前者的真子集，集合不等同于它的真子集。当我们说某一个新类A继承某一既有类B时，表示这个新类A具有既有类B的所有成员，同时对既有类的成员做出修改，或是增加了新的成员。保持已有类的特性而构造新类的过程称为继承。在已有类的基础上新增自己的特性而产生新类的过程称为派生。我们把既有类称为基类（base class）、超类（super class）或者父类（parent class），而派生出的新类，称为派生类（derived class）或子类（subclass）。继承可以使得子类自动具有父类的各种属性和方法，而不需要再次编写相同的代码，从而达到类的复用目的。这样，子类A可以对父类B的定义加以扩充，从而制订出一个不同于父类的定义，让子类具备新的特性。针对公孙龙的“白马非马”的逻辑，从面向对象角度来考虑，“马”与“白马”是两个不同的类，“马”是父类，而“白马”则是“马”的子类（或者称为派生类），后者继承了前者有关“马”的特性，同时添加了自己的新特性——“白色”，故此，父类也不等于它的子类。继承的目的在于实现代码重用，对已有的成熟的功能，子类从父类执行“拿来主义”。而派生的目的则在于，当新的问题出现时，原有代码无法解决（或不能完全解决）时，需要对原有代码进行全部（或部分）改造。对于Java程序而言，设计孤立的类是比较容易的，难的是如何正确设计好的类层次结构，以达到代码高效重用的目的。 8.1.3 多态的含义 从字面上理解，多态（polymorphisn）就是一种类型表现出多种状态。这也是人类思维方式的一种直接模拟，可以利用多态的特征，用统一的标识来完成这些功能。在Java中，多态性分为两类。 （1）方法多态性，体现在方法的重载与覆写上。方法的重载是指同一个方法名称，根据其传入的参数类型、个数和顺序的不同，所调用的方法体也不同，即同一个方法名称在一个类中有不同的功能实现。有关方法的重载，我们已经在7.4节中讲解过。方法的覆写是指父类之中的一个方法名称，在不同的子类有不同的功能实现，而后依据实例化子类的不同，同一个方法可以完成不同的功能。有关方法的覆写，我们将在8.5节中详细讨论。 （2）对象多态性，体现在父、子对象之间的转型上。在这个层面上，多态性是允许将父对象设置成为与一个或更多的子对象相等的技术，通过赋值之后，父对象就可以根据当前被赋值的不同子对象，以子对象的特性加以运作。多态意味着相同的（父类）信息，发送给不同的（子）对象，每个子对象表现出不同的形态。 多态中的一个核心概念就是，子类（派生类）对象可以视为父类（基类）对象。这很容易理解，如下图所示的继承关系中，鱼（Fish）类、鸟（Bird）类和马（Horse）类都继承于父类——动物（Animal），对于这些实例化对象，我们可以说，鱼（子类对象）是动物（父类对象）；鸟（子类对象）是动物（父类对象）；同样的，马（子类对象）是动物（父类对象） 在Java编程里，我们可以用下图来描述。 在上述代码中，第1~4行，分别定义父类对象a，并以子类对象f、b和h分别赋值给a。因为Fish类、Bird类和Horse类均继承于父类Animal，所以子类均继承了父类的move()方法。由于父类Animal的move()过于抽象，不能反映Fish、Bird和Horse等子类中“个性化”的move()方法。这样，势必需要在Fish、Bird和Horse等子类中重新定义move()方法，这样就“覆写”了父类的同名方法。在第2~4行完成定义后，我们自然可以做到： f.move();　 //完成鱼类对象f的移动：鱼儿游 b.move();　 //完成鸟类对象b的移动：鸟儿飞 h.move();　 //完成马类对象h的移动：马儿跑 这并不是多态的表现，因为3种不同的对象对应了3种不同的移动方式，“三对三”平均下来就是“一对一”，何“多”之有呢？当子对象很多时，这种描述方式非常繁琐。 我们希望达到如上述代码第5~7行所示的效果，统一用父类对象a来接收子类对象f、b和h，然后用统一的接口“a.move()”展现出不同的形态。 当“a = f”时，“a.move()”表现出的是子类Fish的move()方法——鱼儿游，而非父类的move()方法。类似的， 当“a = b”时，“a.move()”表现出的是子类Bird的move()方法——鸟儿飞，而非父类的move()方法。 当“a = h”时，“a.move()”表现出的是子类Horse的move()方法——马儿跑，而非父类的move()方法。 这样，就达到了“一对多”的效果——多态就在这里。 父子对象之间的转型包括如下两种形式。 （1）向上转型（Upcast）（自动转型）：父类 父类对象 = 子类实例。将子类对象赋值给父类对象，这样将子类对象自动转换为父类对象。这种转换方式是安全的。例如，我们可以说鱼是动物，鸟是动物，马是动物。这种向上转型在多态中应用得很广泛。 （2）向下转型（Downcast）（强制转型）：子类 子类对象 = (子类) 父类对象。将父类对象赋值给子类对象。这种转换方式是非安全的。例如，如果我们说动物是鱼，动物是鸟，动物是马，这类描述是不全面的。因此，在特定背景下如果需要父类对象转换为子类对象，就必须使用强制类型转换。这种向下转型用得比较少。 8.2 封装的实现 8.2.1 Java访问权限修饰符 在讲解Java面向对象三大特性之前，有必要先介绍一下关于Java访问权限修饰符的知识。在Java中有4种访问权限：公有（public）、私有（private）、保护（protected）、默认（default）。但访问权限修饰符只有3种，因为默认访问权限没有访问权限修饰符。默认访问权限是包访问权限，即在没有任何修饰符的情况下定义的类，属性和方法在一个包内都是可访问的。具体访问权限的规定如下表所示。 私有（private） 默认（default） 保护（protected） 公有（public） 类 只有内部类允许私被访问 可以被当前包访问 只有内部类可以设为保护权访问 可以被所有访问 属性 只能被当前类访问 可以被相同包中的类访问 可以被相同包中的类和当前类的子类访问 可以被所有类访问 方法 只能被当前类访问 可以被相同包中的类访问 可以被相同包中的类和当前类的子类访问 可以被所有类访问 8.2.2 封装问题引例 在8.1.1节中，我们给出类封装性的本质，但对读者来说，这个概念可能还是比较抽象。从哲学的角度来说，我们要“透过现象看本质”，现在本质给出了，如果还不能理解的话，其实是我们没有落实“透过现象”这个流程。下面我们给出一个实例（现象）来说明上面论述的本质。 假设我们把对象的属性（数据）暴露出来，外界可以任意接触到它甚至能改变它。读者可以先看下面的程序，看看会产生什么问题。 范例8-1 类的封装性使用引例—— 一只品质不可控的猫（TestCat.Java） public class TestCat　{　　 public static void main(String[] args){　　 　 MyCat aCat = new MyCat();　　 　 aCat.weight = -10f;　　　 //设置MyCat的属性值　　 　 float temp = aCat.weight;　 //获取MyCat的属性值　　 　 System.out.println(\"The weight of a cat is : \" + temp);　　 　 }　 } class MyCat　{　 public float weight;　//通过public修饰符，开放MyCat的属性给外界　 MyCat(){　　 　 }　 } 保存并运行程序，运行结果如下图所示。 代码详解首先我们来分析一下MyCat类。第15行通过public修饰符，开放MyCat的属性（weight）给外界，这意味着外界可以通过“对象名.属性名”的方式来访问（读或写）这个属性。第16行声明一个无参构造方法，在本例中无明显含义。 第05行，定义一个对象aCat。第08行通过点操作符获得这个对象的值。第09行输出这个对象的属性值。我们需要重点关注第06行，它通过“点操作符”设置这个对象的值（-10.0f）。一般意义上，“-10.0f ”是一个普通的合法的单精度浮点数，因此在纯语法上，它给weight赋值没有任何问题。 但是对于一个真正的对象（猫）来说，这是完全不能接受的，一个猫的重量（weight）怎么可能为负值？这明显是“一只不合格的猫”，但是由于weight这个属性开放给外界，“猫的体重值”无法做到“独立自主”，因为它的值可被任何外界的行为所影响。 那么如何来改善这种状况呢？这时，类的封装就可以起到很好的作用。请参看下节的案例。 8.2.3 类的封装实例 读者可以看到，前面列举的程序都是用对象直接访问类中的属性，在面向对象编程法则里，这是不允许的。所以为了避免发生这样类似的错误，通常要将类中的属性封装，用关键词“private”声明为私有，从而保护起来。对范例TestCat.Java做了相应的修改后，就可构成下面的程序。 范例8-2 类的封装实例—— 一只难以访问的猫（TestCat.Java） 　public class TestCat 　{ 　　 public static void main(String[] args) 　　 { 　　　 MyCat aCat = new MyCat(); 　　　 aCat.weight = -10.0f;　　　 //设置MyCat的属性值 　　 　　　 int temp = aCat.weight;　　 //获取MyCat的属性值 　　 System.out.println(\"The weight of a cat is : \" + temp); 　　 　 } 　} 　 　class MyCat 　{ 　 private float weight;　　　 //通过private修饰符封装属性 　 MyCat() 　　 { 　　　 　　 } 　} 代码详解第13~19行声明了一个新的类MyCat，类中有属性weight，与前面范例不同的是，这里的属性在声明时，前面加上了访问控制修饰符private。【范例分析】可以看到，本程序与上面的范例8-1相比，在声明属性weight前，多了个修饰符private（私有的）。但就是这一个小小的关键字，却使得下面同样的代码连编译都无法通过。 MyCat aCat = new MyCat(); aCat.weight = -10;　　　 //设置MyCat的属性值，非法访问 int temp = aCat.weight;　　//获取MyCat的属性值，非法访问其 所提示的错误如下图所示。 这里的“字段（Field）”就是Java里的“数据属性”。因为weight为私有数据类型，所以对外界是不可见的（The field MyCat.weight is not visible），换句话说，对象不能通过点操作（.）直接访问这些私有属性，因此代码第06行和第08行是无法通过编译的。 这样虽然可以通过封装，达到外界无法访问私有属性的目的，但如果的确需要给对象的属性赋值，该怎么办呢？ 问题的解决方案是，在设计类时，程序设计人员都设计或存/取这些私有属性的公共接口，这些接口的外在表现形式都是公有（public）方法，而在这些方法里，我们可以对存或取属性的操作实施合理的检查，以达到保护属性数据的目的。 通常，对属性值设置的方法被命名为SetXxx()，其中Xxx为任意有意义的名称，这类方法可统称为Setter方法。而对取属性值的方法通常命名为GetYyy，其中Yyy为任意有意义的名称，这类方法可统称为Getter方法。请看下面的范例。 范例8-3 类私有属性的Setter和Getter方法—— 一只品质可控的猫（TestCat.java） 　 public class TestCat 　 { 　　 public static void main(String[] args) 　　 { 　　　　MyCat aCat = new MyCat( ); 　　　　aCat.SetWeight(-10);　　　 //设置MyCat的属性值 　　　　 　　　　float temp = aCat.GetWeight( );　 //获取MyCat的属性值 　　　　System.out.println(\"The weight of a cat is : \" + temp); 　　　　 　　 } 　 } 　 　 class MyCat 　 { 　　　private float weight;　　　 //通过private修饰符封装MyCat的属性 　　　public void SetWeight( float wt) 　　　{ 　　　　 if (wt > 0) 　　　　 { 　　　　　 weight = wt; 　　　　 } 　　　　 else 　　　　 { 　　　　　 System.out.println(\"weight 设置非法 (应该>0). \\n 采用默认值\"); 　　　　　 weight = 10.0f; 　　　　 } 　　　} 　　　public float GetWeight( ) 　　　{ 　　　　 return weight; } 保存并运行程序，结果如下图所示。 代码详解 第17~28行，添加了SetWeight( float wt)方法，第29~32行添加了GetWeight()方法，这些方法都是公有类型的（public），外界可以通过这些公有的接口来设置和取得类中的私有属性weight。第06行调用了SetWeight()方法，同时传进一个“-10f ”的不合理体重值。在SetWeight( float wt)方法中，在设置体重时，程序中加了些判断语句，如果传入的数值大于0，则将值赋给weight属性，否则给出警告信息，并采用默认值。通过这个方法可以看出，经由公有接口来对属性值实施操作，我们可以在这些接口里对这些值实施“管控”，从而更好地控制属性成员。 【范例分析】 可以看到在本程序中，由于weight传进了一个“-10”的不合理的数值（-10后面的f表示这个数是float类型），这样在设置MyCat属性时，因不满足条件而不能被设置成功，所以weight的值采用自己的默认值（10）。这样在输出的时候可以看到，那些错误的数据并没有被赋到属性上去，而只输出了默认值。由此可知，用private可将属性封装起来，当然也可用private把方法封装起来，封装的形式如下。封装属性：private 属性类型 属性名封装方法：private 方法 返回类型 方法名称（参数） 注意 用private声明的属性或方法只能在其类的内部被调用，而不能在类的外部被调用。读者可以先暂时简单地理解为，在类外部不能用对象去调用private声明的属性或方法。 下面的这个范例添加了一个MakeSound()方法，通过修饰符private（私有）将其封装了起来。 范例8-4 方法的封装使用（TestCat.Java） public class TestCat 　 { 　 public static void main(String[] args)　　 { 　　　　MyCat aCat = new MyCat(); 　　　　aCat.SetWeight(-f);　　　 //设置MyCat的属性值 　　　　float temp = aCat.GetWeight(); //获取MyCat的属性值 　　　　System.out.println(\"The weight of a cat is : \" + temp); 　　　　aCat.MakeSound(); 　　　　　　 }　 } class MyCat　 {　　　private float weight;　　　 //通过private修饰符封装MyCat的属性 　　　public void SetWeight( float wt)　　　{　 　　　 if (wt >0 ) 　　　　 {　　　　　 weight = wt; 　　　　 }　　　　 else 　　　　 { 　　　　　 System.out.println(\"weight 设置非法 (应该>). \\n 采用默认值10\");　 　　　　 weight = 10.0f;　 　　　 }　　 　}　　　 public float GetWeight()　　　{　 　　　 return weight;　　　}　　　　 　　private void MakeSound()　 　　{　　　　 System.out.println( \"Meow meow, my weight is \" + weight );　　 　}　 } 保存并运行程序，结果如下图所示。 代码详解 第35行将MakeSound()方法用private来声明。第10行，想通过对象的点操作符“.”来尝试调用这个私有方法。由于私有方法是不对外公开的，因此得到上述的编译错误：“Themethod MakeSound() from the type MyCat is not visible”（在类MyCat中的方法 MakeSound()不可见）。 范例分析】 一旦方法的访问权限被声明为private（私有的），那么这个方法就只能被类内部方法所调用。如果想让上述代码编译成功，其中一种方法是，将第10行的代码删除，而在GetWeight()中添加调用MakeSound()方法的语句， 如下所示。 public float GetWeight() {　 MakeSound();　 //方法内添加的方法调用　 return weight; } 访问权限控制符是对类外而言的，而在同一类中，所有的类成员属性及方法都是相互可见的，也就是说，它们之间是可以相互访问的。在改造GetWeight()后，程序成功运行的结果如下图所示。 如果类中的某些数据在初始化后，不想再被外界修改，则可以使用构造方法配合私有化的Setter 函数来实现该数据的封装， 如下所示。范例8-5 使用构造函数实现数据的封装（TestEncapsulation.Java） 　 class MyCat 　 { 　　 // 创建私有化的属性weight，height 　　 private float weight; 　　 private float height; 　　 // 在构造函数中初始化私有变量 　　 public MyCat( float height, float weight ) 　　 { 　　　　SetHeight( height );// 调用私有方法设置height 　　　　SetWeight( weight );// 调用私有方法设置weight 　　 } 　 　　 //通过private修饰符封装MyCat的SetWeight方法 　　 private void SetWeight( float wt) 　　 { 　　　　if (wt > 0) {　weight = wt;　} 　　　　else　　 { 　　　　　 System.out.println(\"weight 设置非法 (应该>0). 采用默认值10\"); 　　　　　 weight = 10.0f; 　　　　} 　　 } 　　//通过private修饰符封装MyCat的SetHeight方法 　　 private void SetHeight(float ht) 　　 { 　　　　if (ht > 0) {　height = ht;　 } 　　　　else　　{ 　　　　　 System.out.println(\"height 设置非法 (应该>0). 采用默认值20\"); 　　　　　 height = 20.0f; 　　　　} 　　 } 　　 // 创建公有方法GetWeight()作为与外界的通信的接口 　　 public float GetWeight()　 {　　 return weight;　 } 　　 // 创建公有方法GetHeight()作为与外界的通信的接口 　　 public float GetHeight()　 {　　 return height;　 } 　 } 　 　 public class TestEncapsulation 　 { 　　 public static void main( String[] args ) 　　 { 　　　　MyCat aCat = new MyCat( , -5 ); //通过公有接口设置属性值　　 　　　　 　　　　float ht = aCat.GetHeight();　　 //通过公有接口获取属性值height 　　　　float wt = aCat.GetWeight();　　 //通过公有接口获取属性值weight 　　　　System.out.println(\"The height of cat is \" + ht); 　　　　System.out.println(\"The weight of cat is \" + wt); 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 在第07~11行中的MyCat类的构造方法，通过调用私有化SetHeight()方法（在第23~30行定义）和私有化SetWeight()方法（在第14~21行定义）来对height和weight进行初始化。这样类MyCat的对象aCat一经实例化（第41行），name和age私有属性便不能再进行修改，这是因为构造方法只能在实例化对象时自动调用一次，而SetHeight()方法和SetWeight()方法的访问权限为私有类型，外界又不能调用，所以就达到了封装的目的。 【范例分析】 通过构造函数初始化类中的私有属性，能够达到一定的封装效果，但是也不能过度相信这种封装，有些情况下即使这样做，私有属性也有可能被外界修改。例如，在下面就会讲到封装带来的问题。 提示 读者可能会问，到底什么时候需要封装，什么时候不用封装。在这里可以告诉读者，关于封装与否并没有一个明确的规定，不过从程序设计的角度来说，设计较好的程序的类中的属性都是需要封装的。此时要设置或取得属性值，则只能使用Setter和Getter方法，这是一个比较标准的做法。 在Java中，最基本的封装单元是类，类是基于面向对象思想编程的基础，程序员可以把具有相同业务性质的代码封装在一个类里，然后通过共有接口方法向外部提供服务，同时向外部屏蔽类中的具体实现方式。 数据封装的重要目的在于实现“信息隐藏（Information Hidding）”。在类中的“数据成员（属性）”或者“方法成员”，都可以使用关键字“public”“private”“protected”来设置各成员的访问权限。例如，我们可以把“SetHeight()”这个方法封装在“MyCat”类中，通过设置private访问权限，不开放给外界使用，因此，“TestEncapsulation类”就无法调用“SetHeight()”这个方法，来设置Mycat中的height属性值。 封装性是面向对象程序设计的原则之一。它规定对象应对外部环境隐藏它们的内部工作方式。良好的封装可以提高代码的模块化程度，它防止了对象之间不良的相互影响，使程序达到强内聚（许多功能尽量在类的内部独立完成，不让外面干预），弱耦合（提供给外部尽量少的方法调用）的最终目标。 8.3 继承的实现 在前面我们已经了解了类的基本使用方法。对于面向对象的程序而言，它的精华还在于类的继承。继承能以既有的类为基础，进而派生出新的类。通过这种方式便能快速地开发出新的类，而不需编写相同的程序代码，这就是程序代码复用（reuse）的概念。 8.3.1 继承的基本概念 在Java中，通过继承可以简化类的定义，扩展类的功能。在Java中支持类的单继承和多层继承，但是不支持多继承，即一个类只能继承一个类，而不能继承多个类。实现继承的格式如下。class 子类名 extends 父类extends 是Java中的关键词。 Java继承只能直接继承父类中的公有属性和公有方法，而隐含地(不可见地)继承了私有属性。现在假设有一个Person类，里面有name与age两个属性，而另外一个Student类，需要有name、age、school3个属性，如下图所示。因为Person中已存在有name和age两个属性，所以不希望在Student类中重新声明这两个属性，这时就需考虑是否可将Person类中的内容继续保留到Student类中，这就引出了接下来要介绍的类的继承概念。 在这里希望Student类能够将 Person类的内容继承下来后继续使用，可用下图表示，这样就可以达到代码复用的目的。 Java类的继承可用下面的语法来表示。 class 父类　 { 　 // 定义父类 } class 子类extends父类 {　 // 用extends关键字实现类的继承 } 8.3.2 继承问题的引入 首先，我们观察一下下面的例子，在下面的例子中，包括Person和Student两个类。 范例8-6 继承的引出（LeadInherit.Java） 　 class Person { 　　 String name; 　　 int age; 　　 Person( String name, int age ) { 　　　　this.name = name; 　　　　this.age = age; 　　 } 　 　　 void speak() { 　　　　System.out.println( \"我的名字叫：\" + name + \" 我\" + age + \"岁\" ); 　　 } 　 } 　 　 class Student { 　　 String name; 　　 int age; 　　 String school; 　　 Student( String name, int age, String school ) { 　　　　this.name = name; 　　　　this.age = age; 　　　　this.school = school; 　　 } 　　 void speak() { 　　　　System.out.println( \"我的名字叫：\" + name + \" 我\" + age + \"岁\" ); 　　 } 　　 void study() { 　　　　System.out.println( \"我在 \" + school + \"读书\" ); 　　 } 　 } 　 　 public class LeadInherit { 　　 public static void main( String[] args ) { 　　　　// 实例化一个Person对象 　　　　Person person = new Person( \"张三\", 21 ); 　　　　person.speak(); 　　　　// 实例化一个Student对象 　　　　Student student = new Student( \"李四\", 20, \"HAUT\" ); 　　　　student.speak(); 　　　　student.study(); 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 上面代码的功能很简单，在第01~12行定义了Person类，其中第04~07行为Person类的构造方法。第14~29行定义了Student类，并分别定义了其属性和方法。第34行和第37行分别实例化Person类和Student类，并定义了两个对象person和student（首字母小写，别于类名）。通过具体的代码编写，我们可以发现，这两个类中有很多相同的部分，例如，两个类中都有name、age属性和speak()方法。这就造成了代码的臃肿。软件开发的目标是“软件复用，尽量没有重复”，因此，有必要对范例8-6实施改造。 8.3.3 继承实现代码复用 为了简化范例8-6，我们使用继承来完成相同的功能，请参见下面的范例。 范例8-7 类的继承演示程序（InheritDemo.Java） 　 class Person { 　　 String name; 　　 int age; 　　 Person( String name, int age ){ 　　　　this.name = name; 　　　　this.age = age; 　　 }　 　　 void speak(){ 　　　 System.out.println( \"我的名字叫：\" + name + \" ,今年我\" + age + \"岁\" ); 　　 } 　 } 　 　 class Student extends Person { 　　 String school; 　　 Student( String name, int age, String school ){ 　　　　super(name, age); 　　　　this.school = school; 　　 } 　　 void study(){ 　　　　System.out.println( “我在 \" + school + \"读书\" ); 　　 } 　 } 　 public class InheritDemo 　 { 　 　public static void main( String[] args ) 　 　{ 　 　　// 实例化一个Student对象 　 　　Student s = new Student(“张三\",25 ,\"工业大学\"); 　 　　s.speak(); 　 　　s.study(); 　 　} 　 } 保存并运行程序，结果如下图所示。 代码详解第01~11行声明了一个名为Person的类，里面有name与age两个属性和一个方法speak()。其中，第04~07行定义了Person类的构造方法Person( )，用于初始化name和age两个属性。为了区分构造方法Person( )中同名的形参和类中属性名，赋值运算符“=”左侧的“this.”，用以表明左侧的name和age是来自类中。第13~22行声明了一个名为Student的类，并继承自Person类（使用了extends关键字）。 在Student类中，定义了school属性和study()方法。其中，第15~18行定义了Student类的构造方法Student()。虽然在Student类中仅定义了school属性，但由于Student类直接继承自Person类，因此Student类继承了Person类中的所有属性，也就是说，此时在Student类中有3个属性成员，如下图所示。两个（name和age）来自于父类，一个（school）来自于当前子类。 构造方法用于数据成员的初始化，但要“各司其职”，对来自于父类的数据成员，需要调用父类的构造方法，例如，在第16行，使用super关键字加上对应的参数，就是调用父类的构造方法。 而在第17行，来自本类的school属性，直接使用“this.school = school;”来实施本地初始化。同样的，由于Student类直接继承自Person类，Student类中“自动”拥有父类Person类中的方法speak()，加上本身定义的study()方法和Student()构造方法，其内共有3个方法，而不是第15~21行表面看到的2个方法。第28行声明并实例化了一个Student类的对象s。第29行调用了继承自父类的speak()方法。第30行调用了Student类中的自己添加的study()方法。提示在Java中只允许单继承，而不允许多重继承，也就是说一个子类只能有一个父类，但在Java中允许多层继承。 8.3.4 继承的限制 以上实现了继承的基本要求，但是对于继承性而言，实际上也存在着若干限制，下面一一对这些限制进行说明。 限制1：Java之中不允许多重继承，但是可以使用多层继承。所谓的多重继承指的是一个类同时继承多个父类的行为和特征功能。以下通过对比进行说明。范例：错误的继承——多重继承。 class A{　} class B{　} class C extends A,B 　// 错误：多重继承 {　} 从代码中可以看到，类C同时继承了类A与类B，也就是说C类同时继承了两个父类，这在Java中是不允许的，如下图所示。 虽然上述语法有错误，但是在这种情况下，如果不考虑语法错误，以上这种做法的目的是：希望C类同时具备A和B类的功能，所以虽然无法实现多重继承，但是却可以使用多层继承的方式来表示。所谓多层继承，是指一个类B可以继承自某一个类A，而另外一个类C又继承自B，这样在继承层次上单项继承多个类，如下图所示。 class A{　 } 从继承图及代码中可以看到，类B继承了类A，而类C又继承了类B，也就是说类B是类A的子类，而类C则是类A的孙子类。此时，C类就将具备A和B两个类的功能，但是一般情况下，在我们编写代码时，多层继承的层数之中不要宜超过3层。 限制2：从父类继承的私有成员，不能被子类直接使用。子类在继承父类的时候，会将父类之中的全部成员（包括属性及方法）继承下来，但是对于所有的非私有（private）成员属于显式继承，而对于所有的私有成员采用隐式继承（即对子类不可见）。子类无法直接操作这些私有属性，必须通过设置Setter和Getter方法间接操作。 限制3：子类在进行对象实例化时，从父类继承而来的数据成员需要先调用父类的构造方法来初始化，然后再用子类的构造方法来初始化本地的数据成员。 子类继承了父类的所有数据成员，同时子类也可以添加自己的数据成员。但是，需要注意的是，在调用构造方法实施数据成员初始化时，一定要“各司其职”，即来自父类的数据成员需要调用父类的构造方法来初始化，而来自子类的数据成员初始化，要在本地构造方法中完成。在调用次序上，子类的构造方法要遵循“长辈优先”的原则：先调用父类的构造方法（生成父类对象），然后再调用子类的构造方法（生成子类对象）。也就是说，当实例化子类对象时，父类的对象会先“诞生”——这符合我们现实生活中对象存在的伦理。 限制4：被final修饰的方法不能被子类覆写实例，被final修饰的类不能再被继承。 Java的继承性确实在某些时候提高了程序的灵活性和代码的简洁度，但是有时我们定义了一个类却不想让其被继承，即所有继承关系到此为止，如何实现这一目的呢？为此，Java提供了final关键字来实现这个功能。 final在Java之中称为终结器（terminator）： ①在基类的某个方法上加final，那么在子类中该方法被禁止二次“改造”（即禁止被覆写）； ② 通过在类的前面添加final关键字，便可以阻止基类被继承。 范例8-8 final标记的方法不能被子类覆写实例（TestFinalDemo.java） 　class Person 　{ 　　// 此方法声明为final不能被子类覆写 　　final public String talk() 　　{ 　　　return \"Person：talk()\" ; 　　} 　} 　class Student extends Person 　{ 　　public String talk() 　　{ 　　　return \"Student：talk()\" ; 　　} 　} 　public class TestFinalDemo 　{ 　　 public static void main(String args[]) 　　 { 　　　 Student S1=new Student(); 　　　 System.out.println(S1.talk()); 　　 } 　} 保存并运行程序，程序并不能正确运行，会提示如下图所示的错误。 代码详解 第01~08行声明了一个Person类并在类中定义了一个由final修饰的talk( )方法。第09~15行声明了一个Student类，该类使用关键词extends，继承了Person类。在Student类中重写了talk( )方法。第20行新建一个对象，并在第21行调用该对象的talk( )方法。【范例分析】在运行错误界面图中发生了JNI错误（A JNI has occurred），这里的JNI指的是“JavaNative Interface （Java 本机接口）”，由于在第04行，talk( )方法用了final修饰，用它修饰的方法在子类中是不允许覆写改动的，这里final有“一锤定音”的意味。而子类Student在第11~14行尝试推翻终局（final），改动从父类中继承而来的talk( )方法，于是Java虚拟机就“罢工”报错了。 范例8-9 用final继承的限制（InheritRestrict.java） 　 //定义被final修饰的父类 　 final class SuperClass 　 { 　　 String name; 　　 int age; 　 } 　 //子类SubClass继承SuperClass 　 class SubClass extends SuperClass 　 { 　　 //do something 　 } 　 public class InheritRestrict 　 { 　　 public static void main(String[] args) 　　 { 　　　　SubClass subClass = new SubClass(); 　　 } 　 } 保存并编译程序，得到的编译错误信息如下图所示。 代码详解 因为在第02行创建的父类SuperClass前用了final修饰，所以它不能被子类SubClass继承。通过上面的编译信息结果也可以看出：“The type SubClass cannot subclass the final class SuperClass（类型 SubClass 不能成为终态类 SuperClass的子类）”。 8.4 深度认识类的继承 关于继承的问题，有一些概念和过程需要澄清，有些语法和术语需要熟练掌握，下面我们做一个总结。 8.4.1 子类对象的实例化过程 既然子类可以直接继承父类中的方法与属性，那父类中的构造方法是如何处理的呢？子类对象在实例化时，子类对象实例化会默认先调用父类中的无参构造函数，然后再调用子类构造方法。 请看下面的范例，并观察实例化操作流程。 范例8-10 子类对象的实例化（SubInstantProcess.java） 　 class Person 　 { 　　 String name ; 　　 int age ; 　　 public Person() // 父类的构造方法 　　 { 　　　　System.out.println(\"***** 父类构造：1. publicPerson()\") ; 　　 } 　 } 　 class Student extends Person 　 { 　　 String school ; 　　 public Student() // 子类的构造方法 　　 { 　　　　System.out.println(\"####### 子类构造：2. public Student()\"); 　　 } 　 } 　 　 public class SubInstantProcess 　 { 　　 public static void main(String[] args) 　　 { 　　　 Student s = new Student() ; 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 第01~09行声明了一个Person类，在这个类中设计了一个无参构造方法Person()。实际上，构造方法的主要功能是用于构造对象，初始化数据成员，这里仅为了演示方便，输出了“* 父类构造： publicPerson()”的字样。第10~17行声明了一个Student类，此类继承自Person类，它也有一个无参构造方法，并在这个构造方法中输出了“####### 子类构造： public Student()”的字样。第23行声明并实例化了一个Student这个子类对象s。从程序输出结果中可以看到，虽然第23行实例化的是子类的对象，其必然调用的是子类的无参构造方法，但是父类之中的无参构造方法也被默认调用了。由此可以证明：子类对象在实例化时，会默认先去调用父类中的无参构造方法，之后再调用子类本身的相应构造方法。实际上，在本例中，在子类构造方法的首行相当于默认隐含了一个“super()”语句。上面的Student类如果改写成下面的形式，也是合法的。 class Student extends Person{　 String school ; 　 public Student( ) // 子类的构造方法　 {　　 super( ) ;　//隐含了这样一条语句，它负责调用父类构造　 System.out.println(\"####### 子类构造： public Student()\");　 }}其中，如果用户显式地用super( )去调用父类的构造方法，那么它必须出现在这个子类构造方法中的第1行语句。详细讨论请参见下一节。 8.4.2 super关键字的使用 在上面的程序中，我们提到了super关键字的使用，那super到底是什么？从英文本意来说，它表示“超级的”，从继承体系上，父类相对于子类是“超级的”，因此，有时候我们也称父类为超类（super-class）。从范例8-10后面的解释中，读者应该可以发现，super关键字出现在子类中，而且主要目的是，在子类中调用父类的属性或方法。这里也多少有点“互不干涉内政”的意思，虽然通过继承，子类拥有父类的某些数据成员或方法，但是如果想对这些类中父类的成员（数据或方法）进行操作，还得请父类自己“亲自出马”，自己的事情自己干。而super关键字就是打通父类和子类之间协作的桥梁。范例8-10仅仅显示的是如何调用父类的无参构造方法。如果子类继承了父类的数据成员，这时就需要调用父类的有参构造方法，来初始化来自于父类的数据成员，那如何做到这一点呢？这就需要显式地调用父类中的有参构造方法super(参数1，参数2…)。 将范例8-10做相应的修改，就构成了下面的范例。 范例8-11 super调用父类中的构造方法（SuperDemo.Java） 　 class Person 　 { 　　 String name; 　　 int age; 　　 　　 public Person( String name, int age )　 // 父类的构造方法 　　 { 　　　　this.name = name; 　　　　this.age = age; 　　 } 　 } 　 　 class Student extends Person 　 { 　　 String school; 　　　　　　　　　　　　　 // 子类的构造方法 　　 public Student(String name, int age, String school) 　　 {　 　　　　super( name, age );　　　　 // 用super调用父类中的构造方法 　　　　this.school = school; 　　 } 　 } 　 　 public class SuperDemo 　 { 　　 public static void main( String[] args ) 　　 { 　　　　Student s = new Student(\"Jack\", 30, \"HAUT\"); 　　System.out.println( \"Name：\" + s.name + \", Age：\" + s.age + \", School：\" + s.school ); 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 第01~11行声明了一个名为Person的类，里面有name和age两个属性，并声明了一个含有两个参数的构造方法。第13~22行声明了一个名为Student的类，此类继承自Person类。第17~21行声明了一个子类的构造方法Student()，在此方法中传递了3个形参name、age和school，其中，两个形参name和age用于super()方法，借此调用父类中有两个参数的构造方法。注意到语句“super( name, age );”位于子类构造方法中的第一行（第19行）。第20行用形参school本地初始化子类自己定义的数据成员school（用this.来区分同名的形参）。第28行声明并实例化了一个Student类的对象s，然后传递了3个实参用于初始化Student类的3个数据成员（其中2个来自父类Person的继承，1个来自于自己类中的定义）。读者可以看到，本例与范例8-10程序基本模式是一致的，不同之处在于，在子类的构造方法中明确地使用super( name, age )，指明调用的是父类中含有两个参数的构造方法。需要读者注意的是：调用super()必须写在子类构造方法的第一行，否则编译不予通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有提供这种形式的构造方法，那么在编译的时候就会报错。例如，如果我们很“调皮”地调整了范例8-11中的第19和20行代码的先后次序，就会得到如下图所示的编译错误：“Constructor callmust be the first statement in a constructor（构造方法调用，必须是构造方法的第一个 事实上，super关键字不仅可用于调用父类中的构造方法，也可用于调用父类中的属性或方法，如下面的格式所示。 super.父类中的属性;super.父类中的方法() ; 对范例8-11稍加改造，就形成了通过super调用父类属性和方法的范例8-12。范例8-12 通过super调用父类的属性和方法（SuperDemo2.Java） 　 class Person 　 { 　　　String name; 　　　int age; 　　　// 父类的构造方法 　　　public Person() 　　 { 　　　} 　　　public String talk() 　　 { 　　　　 return \"I am ：\" + this.name + \", I am： \" + this.age + \" years old\"; 　　 } 　 } 　 class Student extends Person 　 { 　　　 String school; 　　　 // 子类的构造方法 　　　 public Student( String name, int age, String school ) 　　　{ 　　　　　// 在这里用super调用父类中的属性 　　　　　super.name = name; 　　　　　super.age = age; 　 　　　　　// 调用父类中的talk()方法 　　　　　System.out.print( super.talk() ); 　 　　　　　 // 调用本类中的school属性 　　　　　 this.school = school; 　 } 　 } 　 　 public class SuperDemo 3　 { 　　　public static void main( String[] args ) 　　　{ 　　　　　Student s = new Student( \"Jack\", , \"HUAT\" ); 　　　　　System.out.println( \",I am form ：\" + s.school ); 　　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 第01~13行声明了一个名为Person的类，并声明了name和age两个属性、一个返回String类型的talk()方法，以及一个无参构造方法Person()，父类的构造方法是个空方法体，它并没有实施初始化。第14~30行声明了一个名为Student的类，此类直接继承自Person类。第21行和第22行，通过“super.属性”的方式调用父类中的name和age属性，并分别赋值。第25行通过“super.方法名”的方式调用父类中的talk()方法，打印信息。从程序中可以看到，子类Student可以通过super调用父类中的属性或方法。但是细心的读者在本例 中可以发现，如果第21行、第22行、第25行换成this调用也是可以的，那为什么还要用super呢？super 是相对于继承而言的。super 代表的是当前类的父类，而this是代表当前类。如果父类的属性和方法的访问权限不是private（私有的），那么这些属性和方法在子类中是可视的，换句话说，这些属性和方法也可视为当前类所有的，那么用“this.”来访问也是理所当然的。如果子类对“父类”很“见外”，分得很清楚，那么就可用 “super.”访问来自于父类的属性和方法。8.4.3 限制子类的访问有时候，父类也想保护自己的“隐私”，即使自己的成员被子类继承了，但并不希望子类可以访问自己类中全部的属性或方法，这时，就需要将一些属性与方法隐藏起来，不让子类去使用。为此可在声明属性或方法时加上“private”关键字，表示私有访问权限，即除了声明该属性或方法的所在类，其他外部的类（包括子类）均无权访问。 范例8-13 限制子类的访问（RestrictVisit.Java） 　class Person 　{ 　　 // 在这里将属性封装 　　 private String name ; 　　 private int age ; 　} 　class Student extends Person 　{ 　　 // 在这里访问父类中被封装的属性 　　 public void setVar() 　　 { 　　　 name = \"张三\" ; 　　　 age = 25 ; 　　} 　} 　 　class RestrictVisit 　{ 　　 public static void main(String[] args) 　　 { 　　　 new Student().setVar() ; 　　} 　} 保存并编译程序，结果如下图所示。 代码详解 Student类继承自Person类，所以父类的数据（属性）成员name和age也被子类继承了，但是子类相对于父类也属于外类，在父类中，数据成员name和age的访问权限被设置为private，故子类即使继承了这个数据成员，也无法访问，它们在子类中均“不可视”（“The field Person.age/name is not visible”），所以在第12~13行会出现编译错误。此时，即使在属性成员前加上“super.”，也不会编译成功，这体现了类的封装性。12　　　super.name = \"张三\" ;　//name不可视，编译错误13　　　super.age = 25 ;　　 // age不可视， 编译错误在代码的第21行中，代码的前半部分“new Student()”创建一个无名的Student对象。一旦有了对象，就可以通过“对象名.方法名()”的方式调用setVar()方法。这种创建无名对象的方式只能临时创建一个对象，使用一次后即自动销毁了。虽然父类的私有成员，外部（包括子类）无法访问，但是在父类内部，自己的属性和方法彼此之间，是不受访问权限约束的，换句话说，父类的方法可以无障碍地访问父类的任何属性和访问。 针对范例8-13存在的问题，我们可以用父类的方法（如构造方法）来访问父类的私有数据成员。请参见下面的范例。 范例8-14 子类访问父类的私有成员（RestrictVisit2.Java） 　 class Person{ 　　 // 在这里使用private将属性封装 　　 private String name; 　　 private int age; 　　 Person(String name, int age) 　　 { 　　　　this.name = name; 　　　　this.age = age; 　　 } 　　 // 在这里设置属性的值 　　 void setVar(String name, int age) 　　 { 　　　　this.name = name; 　　　　this.age = age; 　　 }　 　　 void print() 　　 { 　　　　System.out.println(\"I am : \" + name + \", I am : \" + age + \" years old\"); 　　 } 　 } 　 class Student extends Person{ 　　 Student(String name, int age) 　　 { 　　　　super(name, age); 　　 } 　　 /*　 　　 void Test () // 在这里尝试访问父类中被封装的属性 　　 { 　　　　System.out.println(\"I am : \" + name + \", I am : \" + age + \" years old\"); 　　 } 　　 */ 　 } 　 　 class RestrictVisit2{ 　　 public static void main( String[] args ) 　　 { 　　　　Student s = new Student(\"Jack\", ); 　　　　s.print(); 　　　　s.setVar(\"Tom\", ); 　　　　s.print(); 　　　　// s.Test(); 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 在第01~20行，定义了Person类，里面定义了构造方法Person()和设置属性值的方法setVar()，表面上看来，这两个方法的方法体完全相同，为什么还设置为两个不同的方法呢？其实这是有差别的。构造方法Person()仅仅是在实例化对象时自动调用（如第37行），且仅能调用一次。但如果对象诞生之后，我们想修改属性的值，那该怎么办？这时就需要一个专门的设置属性值的方法——setVar()，它可以在对象诞生后调用任意多次（如第39行）。 在第21~32行，定义了Student类，该类继承自Person类，那么Person类所有成员（包括私有的）都被“照单全收”地继承过来了，但在父类Person中，被private修饰的属性成员name和age（第03~04行），在子类中不能被直接访问。然而，有一个基本的原则就是，父类自己的方法可以不受限地访问父类的属性和方法。因此在Student类的构造方法中，使用“super(name, age)”（第24行）调用父类的构造方法，而父类的构造方法访问自己的属性成员是“顺理成章”的。第27~30行，尝试定义一个Test方法，并在第41行尝试调用这个方法。这是无法完成的任务，因为子类的方法尝试访问父类的私有成员——这违背了类的封装思想，因此无法通过编译，在本例中我们将这部分代码注释起来了。因为Student类继承自Person类，所以它也继承了父类的setVar()方法和print()方法，因此，在第38~40行中，可以很自然地调用这些方法。 有一个细节需要读者注意，这些方法操作的是来自父类的私有属性成员name和age。这还是体现了我们刚才提及的原则——父类自己的方法可不受限地访问自己的属性和方法，这里的属性name、age及setVar()方法和print()方法通通来自一个类——Person，也就是说，“大家都是自己人”，自然就不能“见外”。 但是，如果我们在子类Student中定义一个方法print()，如下所示。class Student extends Person{　 Student(String name, int age)　 {　　 super(name, age);　 }　 　 void print() //在子类中定义自己的print方法　 {　　 System.out.println(\"I am : \" + name + \", I am : \" + age + \" years old\");　 }　 } 从上面的代码可以看出，子类Student中的print()方法和父类的print()一模一样，读者可以尝试编译一下， 范例8-14中的代码是无法通过编译的，这是为什么呢？这就涉及我们下面要讲到的知识点—覆写。 8.5 覆写 8.5.1 属性的覆盖 所谓的属性覆盖（或称覆写），指的是子类定义了和父类之中名称相同的属性。观察如下代码。 范例8-15 属性（数据成员）的覆写（OverrideData.java） 　 class Book 　 { 　　 String info = \"Hello World.\" ; 　 } 　 class ComputerBook extends Book 　 { 　　 int info = 0 ;　 // 属性名称与父类相同 　　 public void print() 　　 { 　　　　System.out.println(info) ; 　　　　System.out.println(super.info) ; 　　 } 　 } 　 　 public class OverrideData 　 { 　　 public static void main(String args[]) 　　 { 　　　　ComputerBook cb = new ComputerBook() ; // 实例化子类对象 　　　　cb.print() ; 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 第01~04行，定义了类Book，其中第03行定义了一个String类型的属性info。 第05~13行，定义了类ComputerBook，它继承于类Book。在类ComputerBook中，定义了一个整型的变量info，它的名称与从父类继承而来的String类型的属性info相同（第07行）。从运行结果可以看出，在默认情况下，在不加任何标识的情况下，第10行输出的info是子类中整型的info，即100。第10行代码等价于如下代码。System.out.println(this.info) ;由于在父类Book中，info的访问权限为默认类型（即其前面没有任何修饰符），那么在子类ComputerBook中，从父类继承而来的字符串类型的info，子类是可以感知到的，可以通过“super.父类成员”的模式来访问，如第11行所示。 然而，范例8-15所示的代码并没有太大的意义，它并没有实现真正的覆写。从开发角度来说，为了满足类的封装型，类中的属性一般都需要使用private封装，一旦封装之后，子类根本就“看不见”父类的属性成员，子类定义的同名属性成员，其实就是一个“全新的”数据成员，所谓的覆写操作就完全没有意义了。8.5.2 方法的覆写“覆写（Override）”的概念与“重载（Overload）”有相似之处。所谓“重载”，即方法名称相同，方法的参数不同（包括类型不同、顺序不同和个数不同），也就是它们的方法签名（包括方法名+参数列表）不同。重载以表面看起来一样的方式——方法名相同，却通过传递不同形式的参数，来完成不同类型的工作，以这样“一对多”的方式实现“静态多态”。当一个子类继承一个父类，如果子类中的方法与父类中的方法的名称、参数个数及类型且返回值类型等都完全一致时，就称子类中的这个方法“覆写”了父类中的方法。同理，如果子类中重复定义了父类中已有的属性，则称此子类中的属性覆写了父类中的属性。class Super　　　//父类{　 返回值类型 方法名（参数列表）　 {　}}class Sub extends Super //子类{　 返回值　方法名（参数列表）//与父类的方法同名，覆写父类中的方法　 {　 }}再回顾一下在范例8-14留下的问题，子类Student中的print()方法和父类的print()一模一样，那么子类的print()方法就完全覆盖了父类的print()方法。而子类自己的print()方法是无法访问父类的私有属性成员的——这是封装性的体现，因此就无法通过编译。下面我们再举例说明这个概念。范例8-16 子类覆写父类的实现（Override.java） 　 class Person 　 { 　　 String name; 　　 int age; 　　 public String talk() 　　 { 　　　　return \"I am ：\" + this.name + \", I am \" + this.age + \" years old\"; 　　 } 　 } 　 class Student extends Person 　 { 　　 String school; 　　 public Student( String name, int age, String school ) 　　 { 　　　　// 分别为属性赋值 　　　　this.name = name;　//super.name = name; 　　　　this.age = age;　 //super.age = age; 　　　　this.school = school; 　　 } 　 　　 // 此处覆写Person中的talk()方法 　　 public String talk() 　　 { 　　　　return \"I am from \" + this.school ; 　　 } 　 } 　 　 public class Override 　 { 　　 public static void main( String[] args ) 　　 { 　　　　Student s = new Student( \"Jack \", 25 , \"HAUT\" ); 　　　　// 此时调用的是子类中的talk()方法 　　　　System.out.println( s.talk() ); 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 第01~09行声明了一个名为Person的类，里面定义了name和age两个属性，并声明了一个talk()方法。 第10~26行声明了一个名为Student的类，此类继承自Person类，也就继承了name和age属性，同时声明了一个与父类中同名的talk()方法，此时Student类中的talk()方法覆写了Person类中的同名talk()方法。 第32行实例化了一个子类对象，并同时调用子类构造方法为属性赋初值。注意到name和age在父类Person中的访问权限是默认的（即没有访问权限的修饰符），那么它们在子类中是可视的，也就是说，在子类Student中，可以用“this.属性名”的方式来访问这些来自父类继承的属性成员。如果想分得比较清楚，也可以用第16行和第17行注释部分的表示方式，即用“super.属性名”的方式来访问。 第34行用子类对象调用talk()方法，但此时调用的是子类中的talk()方法。从输出结果可以看到，在子类Student中覆写了父类Person中的talk()方法，所以子类对象在调用talk()方法时，实际上调用的是子类中定义的方法。另外可以看到，子类的talk()方法与父类的talk()方法在声明权限时，都声明为public，也就是说这两个方法的访问权限都是一样的。 从范例8-16程序中可以看出，第34行调用talk()方法，实际上调用的只是子类的方法，那如果的确需要调用父类中的方法，又该如何实现呢？请看下面的范例，此范例修改自上一个范例。范例8-17 super调用父类的方法（Override2.java） class Person 　 { 　　 String name; 　　 int age; 　　 public String talk( ) 　　 { 　　　　return \"I am \" + this.name + \", I am \" + this.age + \" years old\"; 　　 } 　 } 　 class Student extends Person 　 { 　　 String school; 　　 public Student( String name, int age, String school ) 　　 { 　　　　// 分别为属性赋值 　　　　this.name = name;　 //super.name = name; 　　　　this.age = age;　　 //super.age = age; 　　　　this.school = school; 　　 } 　 　　 // 此处覆写Person中的talk()方法 　　 public String talk( ) 　　 { 　　　　return super.talk( )+ \", I am from \" + this.school ; 　　 } 　 } 　 　 public class Override 9　 { 　　 public static void main( String[ ] args ) 　　 { 　　　　Student s = new Student( \"Jack \", , \"HAUT\" ); 　　　　// 此时调用的是子类中的talk( )方法 　　　　System.out.println( s.talk( ) ); 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 第01~09行声明了一个Person类，里面定义了name和age两个属性，并声明了一个talk( )方法。 第10~26行声明了一个Student类，此类继承自Person，因此也继承了来自Person类的name和age属性。其中 第13~19行定义了Student类的构造方法，并对数据成员实施了初始化。由于声明了一个与父类中同名的talk()方法，因此Student类中的talk()方法覆写了Person类中的talk()方法，但在 第24行通过super.talk()方式调用了父类中的talk()方法。由于父类的talk()方法返回的是一个字符串，因此可以用连接符“+”连接来自子类的字符串：\", I am from \" + this.school”，这样拼接的结果一起又作为子类的talk()方法的返回值。 第32行实例化了一个子类对象，并同时调用子类构造方法为属性赋初值。 第34行用子类对象调用talk()方法，但此时调用的是子类中的talk()方法。由于子类的talk()方法返回的是一个字符串，因此可以作为System.out.println()的参数，将字符串输出到屏幕上。从程序中可以看到，在子类中可以通过super.方法()调用父类中被子类覆写的方法。在完成方法的覆写时，读者应该注意如下几点。 （1）覆写的方法的返回值类型必须和被覆写的方法的返回值类型一致。 （2）被覆写的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆写条件，仍然会发生编译错误。反之亦然。即使父类和子类中的方法都是静态的，并且满足覆写条件，但是仍然不会发生覆写，因为静态方法在编译时就和类的引用类型进行匹配。 （3）被覆写的方法不能拥有比父类更为严格的访问控制权限。访问权限的大小通常依据下面的次序：私有（private） 8.5.3 关于覆写的注解——@Override Annotation（中文翻译为“注解”或“注释”）实际上表示的是一种注释的语法，这种注释和前面章节讲到的代码的注释是不一样的，代码的注释（如单行注释用双斜杠“//”，多行注释用“/…/等”）是给程序员看的，其主要目的是增加代码的可读性，便于代码的后期维护。而这里的Annotation主要服务于编译器，属于一种配置信息。早期的Java程序提倡程序与配置文件相分离，代码是代码，注释是注释，二者“井水不犯河水”，但后来的实践发现，配置文件过多，以至于配置信息修改起来非常困难，所以将配置信息直接写入到程序之中的理念又重新得到应用。 在JDK 1.5之后，Java系统中内建了3个Annotation： @Deprecated、@SuppressWarnings和@Override，下面分别给予简要介绍。在场景下，当我们需要标识某个方法过时，可以使用@Deprecated 的注解来实现。而在另外一个场景，某些代码有点“无伤大雅”的小问题，你自己也明明知道这些小问题是能够承受的，但是编译器还是不停地“善意”地警告（Warning）你，是不是觉得很烦？而在这个时候，如果你不想让某些警告信息显示的话，就可以使用@SuppressWarnings 的注解压制警告的信息。而应用更广的注解是@Override，这个注解和我们前面方法的覆写（Override）密切相关，甚至可以说，是为其“量身打造”的。通过前面的学习，我们知道，如果要进行方法的覆写，那么要求是：方法名称、参数的类型及个数完全相同，然后，由于人的思维是存在盲点的，程序员在开发代码过程当中，完全可能“码不达意”，有可能会由于手误等原因导致方法不能被正确地覆写。请参见下面的程序。 范例8-18 由于手误导致覆写错误(OverrideError.java) 　 class Message 　 { 　　 public String tostring()　//原本打算覆写toString() 　　 { 　　　　return \"Hello World .\"; 　　 } 　 } 　 public class OverrideError 　 { 　　 public static void main( String[] args ) 　　 { 　　　　System.out.println( new Message() ); 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 第03~06行原本打算覆写toString方法，却由于手误导致覆写“错误”——tostring()，其中的字符“S”被错误小写，而Java是区分大小写的，这时不会产生编译错误，因为JDK会认为tostring()是一个新的方法，可是从实际需求上讲，这个方法应该是方法toString()的覆写。这种语义上的错误远远比语法错误难找得多。因此，为了保证这种错误能在程序编译的时候就可以发现，可在方法覆写时增加上“@Override”注解。@Override用在方法之上，就是用来告诉编译器，这个方法是用来覆写来自父类的同名方法，如果父类没有这个所谓的“同名”方法，就会发出警告信息。我们添加注解到上面的范例中，就可以得到如下范例。 范例8-19 使用@Override Annotation(OverrideAnnotation.java) 　 class Message 　 { 　　 @Override 　　 public String tostring()　// 这行会发生编译错误 　　 { 　　　　return \"Hello World .\"; 　　 } 　 } 　 　 public class OverrideAnnotation 　 { 　　 public static void main( String[] args ) 　　 { 　　　　System.out.println( new Message() ); 　　 } 　 } 代码详解 第04~07行同样由于“手误”，并没有达到覆写toString方法的目的，但是在命令行编译时就会发生编译错误提示：“错误： 方法不会覆盖或实现超类型的方法”，如下图所示。这样一来，由于添加了注解@Override，就可以及时在编译时发现错误，并提示用户及时改正错误，以防日后维护困难。作为一个良好的编程习惯，建议读者在“覆写”父类方法时，养成书写这个注解的习惯。 Eclipse作为优秀的IDE开发环境，即使在不编译代码的情况下，都会友好地提示：“The method tostring() of type Message must override or implement a supertypemethod（类型为 Message 的方法 tostring()必须覆盖或实现超类型方法）”。 如果将注解提示的错误纠正过来，也就是将范例中的第04行“public Stringtostring()”纠正为“public String toString()”，完成了真正的覆写，终于没有错误了，正确的运行结果如下图所示。 8.6 多态的实现 在前面已经介绍了面向对象的封装性和继承性。下面就来看一下面向对象中的第三个重要的特性——多态性。 8.6.1 多态的基本概念 在深度理解多态性概念之前，请读者先回顾一下先前学习的重载概念。 重载的表现形式就是调用一系列具有相同名称的方法，这些方法可根据传入参数的不同而得到不同的处理结果，这其实就是多态性的一种体现，属于静态多态，即同一种接口，不同的实现方式。 这种多态是在代码编译阶段就确定下来的。还有一种多态形式，在程序运行阶段才能体现出来，这种方式称为动态联编，也称为晚期联编（Late Bingding）。 下面用一个范例简单地介绍一下多态的概念。范例8-20 了解多态的基本概念（Poly.java） 　 class Person 　 { 　　 public void fun1 () 　　 { 　　　　System.out.println( \"*****--fun1()我来自父类Person\" ); 　　 } 　 　　 public void fun2( ) 　　 { 　　　　System.out.println( \"*****--fun2()我来自父类Person\" ); 　　 } 　 } 　 　 // Student类扩展自Person类，也就继承了Person类中的fun1()、fun2()方法 　 class Student extends Person 　 { 　　 // 在这里覆写了Person类中的fun1()方法 　　 public void fun1( ) 　　 { 　　　　System.out.println( \"#######--fun1()我来自子类 Student\" ); 　　 } 　 　　 public void fun3( ) 　　 { 　　　　System.out.println( \"#######--fun3() 我来自子类 Student\" ); 　　 } 　 } 　 　 public class Poly 　 { 　　 public static void main( String[] args ) 　　 { 　　　　// 此处父类对象由子类实例化 　　　　Person p = new Student(); 　　　　// 调用fun1()方法，观察此处调用的是哪个类里的fun1()方法 　　　　p.fun1(); 　　　　p.fun2(); 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 第01~12行声明了一个Person类，此类中定义了fun1( )和fun2( )两个方法。 第15~27行声明了一个Student类，此类继承自Person类，也就继承了Person类中的fun1( )和fun2( )方法。在子类Student中重新定义了一个与父类同名的fun1( )方法，这样就达到了覆写父类fun1( )的目的。第34行声明了一个Person类（父类）的对象p，之后由子类对象去实例化此对象。 第36行由父类对象调用fun1( )方法。 第37行由父类对象调用fun2( )方法。从程序的输出结果中可以看到，p是父类Person的对象，但调用fun1( )方法的时候并没有调用Person的fun1( )方法，而是调用了子类Student中被覆写了的fun1( )方法。 对于第34行的语句：Person p = new Student( )，我们分析如下。在赋值运算符“=”左侧，定义了父类Person对象p，而在赋值运算符“=”右侧，用“new Student( )”声明了一个子类无名对象，然后将该子类对象赋值为父类对象p，事实上，这时发生了向上转型。本例中展示的是一个父类仅有一个子类，这种“一对一”的继承模式，并没有体现出“多”态来。在后续章节的范例中，读者就会慢慢体会到多态中的“多”从何而来。8.6.2 方法多态性在Java中，方法的多态性体现在方法的重载，在这里我们再用多态的眼光复习一下这部分内容，相信你会有更深入的理解。方法的多态即是通过传递不同的参数来令同一方法接口实现不同的功能。 下面我们通过一个简单的方法重载的例子来了解Java方法多态性的概念。范例8-21 对象多态性的使用（FuncPoly.java） 　 public class FuncPoly { 　　 //定义了两个方法名完全相同的方法，该方法实现求和的功能 　　 void sum(int i ){ 　　　　 System.out.println(\"数字和为：\" + i); 　　　} 　　　void sum(int i , int j ){ 　　　　 System.out.println(\"数字和为：\" + ( i + j)); 　　　} 　　　public static void main(String[] args){ 　　　　 FuncPoly demo = new FuncPoly(); 　　　　 demo.sum(1);//计算一个数的和 　　　　 demo.sum(2, 3);//计算两个数的和 　　　} } 保存并运行程序，结果如下图所示。 代码详解 在FuncPoly类中定义了两个名称完全一样的方法sum( )（第03~08行），该接口是为了实现求和的功能，在第11行和第12行分别向其传递了一个和两个参数，让其计算并输出求和结果。同一个方法（方法名是相同的）能够接受不同的参数，并完成多个不同类型的运算，因此体现了方法的多态性。8.6.3 对象多态性在讲解对象多态性之前需要了解两个概念：向上转型和向下转型。 （1）向上转型。在范例8-20中，父类对象通过子类对象去实例化，实际上就是对象的向上转型。向上转型是不需要进行强制类型转换的，但是向上转型会丢失精度。 （2）向下转型。与向上转型对应的一个概念就是“向下转型”，所谓向下转型，也就是说父类的对象可以转换为子类对象，但是需要注意的是，这时则必须进行强制的类型转换。 以上内容可以概括成下面的两句话。（1）向上转型可以自动完成。（2）向下转型必须进行强制类型转换。注意读者需要注意的是，并非全部的父类对象都可以强制转换为子类对象，毕竟这种转换是不安全的。下面我们通过编程实现8.1.3节提及的例子，来说明多态在面向对象编程中不可替代的作用。 范例8-22 使用多态（ObjectPoly.java） 　 class Animal{ 　　 public void move(){ 　　　　System.out.println(\"动物移动！\"); 　　 } 　 } 　 class Fish extends Animal{ 　　 //覆写了父类中的move方法 　　 public void move(){ 　　　　System.out.println(\"鱼儿游！\"); 　　 } 　 } 　 class Bird extends Animal{ 　　 //覆写了父类中的move方法 　　 public void move(){ 　　　　System.out.println(\"鸟儿飞！\"); 　　 } 　 } 　 class Horse extends Animal{ 　　 //覆写了父类中的move方法 　　 public void move(){ 　　　　System.out.println(\"马儿跑！\"); 　　 } 　 } 　 public class ObjectPoly { 　　 public static void main(String[] args){ 　　　　Animal a; 　　　　Fish f = new Fish(); 　　　　Bird b = new Bird (); 　　　　Horse h = new Horse(); 　　　　a = f;　 a.move(); //调用Fish的move()方法，输出“鱼儿游！” 　　　　a = b;　 a.move();　//调用Bird的move()方法，输出”鸟儿飞！“ 　　　　a = h;　 a.move();　//调用Horse的move()方法，输出“马儿跑！” 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解 在第01~05行，定义了Animal类，其中定义了动物的一个公有的行为move（移动），子类Fish、Bird、Horse分别继承Animal类，并覆写了Animal类的move方法，实现各自独特的移动方式：鱼儿游；鸟儿飞；马儿跑。 第26行声明了一个父类Animal的对象a，但没有真正实例化a。 在第27~29行分别实例化了3个子类对象：f、b和h。 第30~32行，通过赋值操作，将这些子类对象向上类型转换为Animal类型。然后经过父类对象a调用其move方法，这时我们发现，实际调用的却是各个子类对象的move方法。父类对象依据被赋值的每个子类对象的类型，做出恰当的响应（即与对象具体类别相适应的反应），这就是对象多态性的关键思想。同样的消息或接口（在本例中都是move）在发送给不同的对象时，会产生多种形式的结果，这就是多态性的本质。利用对象多态性，我们可以设计和实现更具扩展性的软件系统。提示简单来说，继承是子类使用父类的方法，而多态则是父类使用子类的方法。但更为确切地说，多态是父类使用被子类覆盖的同名方法，如果子类的方法是全新的，不存在与父类同名的方法，那么父类也不可能使用子类自己独有的“个性化”方法。有一点需要读者注意，即使实施向上转型，父类对象所能够看见的方法依然还是本类之中所定义的方法（即被子类覆盖的方法）。如果子类扩充了一些新方法的话，那么父类对象是无法找到的。请观察下面的范例。 范例8-23 父类对象找不到子类的扩充方法（NewMethodTest.java） 　class baseClass 　{ 　　 public void print() 　　 { 　　　 System.out.println(\"*****--父类baseClass：print()\") ; 　　 } 　} 　class subClass extends baseClass 　{ 　　 public void print() // 方法覆写 　　 { 　　　 System.out.println(\"#######--子类subClass：public void print()\") ; 　　 } 　　 public void getB() // 此方法为子类扩充的功能 　　 {　 　　　 System.out.println(\"#######--子类subClass：getB()，子类自己扩充的方法。\") ; 　　 } 　} 　public class NewMethodTest 　{ 　　 public static void main(String args[]) 　　 { 　　　 baseClass baseObj = new subClass() ; // 实例化子类对象 　　　 baseObj.print() ;　 　　　 // baseObj.getB() ; // 这个方法父类无法找到 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解 第01~07行，定义了父类baseClass，其中包括了print()方法。 第08~18行，定义了子类subClass，它继承自父类A，其中定义了print()方法，这样就覆写了父类的同名print()方法，此外在子类subClass中， 在第14~17行，还定义了一个新扩充的方法getB()。 在第23行，通过调用子类的构造方法“new subClass ()”，实例化子类对象，并将其赋值给父类对象baseObj， 在第24行，从上面运行结果可以看出，baseObj调用的子类所定义的print()方法， 但值得我们关注的是，如果去掉第25行的注释符号“//”，就会产生如下的编译错误：“The method getB() is undefined for the baseClass （没有为类型baseClass定义方法 getB()）”，如下图所示。尽管这个父类对象baseObj的实例化依靠的是子类完成的，但是它能够看见的还是自己本类所定义的方法名称，如果方法被子类覆写了，则调用的方法体也是被子类所覆写过的方法。这其实也体现了“父母不管儿女事”的这种低耦合思想。如果说现在非要去调用subClass类的getB()方法，那么就需要进行向下转型，即将父类对象变为子类实例，向下转型需要采用强制转换的方式完成。请参见如下范例。 范例8-24 实现向下转型（DownCastTest.java） 　class baseClass 　{ 　　 public void print() 　　 { 　　　 System.out.println(\"*****--父类baseClass：public void print(){}\") ; 　　 } 　} 　class subClass extends baseClass 　{ 　　 public void print() // 方法覆写 　　 { 　　　 System.out.println(\"#######--子类subClass：print()\") ; 　　 } 　　 public void getB() // 此方法为子类扩充的功能 　　 {　 　　　 System.out.println(\"#######--子类subClass：getB()，子类扩充方法。\") ; 　　 } 　} 　 　public class DownCastTest 　{ 　　 public static void main(String args[]) 　　 { 　　　 baseClass baseObj = new subClass() ; // 实例化子类对象 　　　 baseObj.print() ;　 //调用子类subClass的 print() 　　　 subClass subObj = (subClass) baseObj ; // 向下转型，强制完成 　　　 subObj.getB() ; // 这个方法父类无法找到，但子类对象可以找到 　　 } 　} 保存并运行程序， 结果如下图所示。 代码详解 本范例和上面一个范例基本相同，差别之处仅体现在第26~27行上。在第26行，将父类的对象baseObj强制类型转换为子类对象。 在前面的范例中，对于子类添加的新方法getB()，父类的对象无法找到这个方法。但是，在第26行中，对象a前面的“(subClass)”，表明要把父类对象baseObj强制转换成子类subClass类型。然后将转换后的结果赋给一个子类subClass定义的引用subObj，于是subObj就可以顺利找到这个getB()方法（第27行）。从上面的几个范例分析来看，我们可以用一句话来概括这类关系：“在形式上，类定义的对象只能看到自己所属类中的成员。” 虽然通过向上类型转换，子类对象可以给父类对象赋值，但父类对象也仅能看到在子类中被覆盖的成员（这些方法也在父类定义过了），父类对象无法看到子类的新扩充方法。8.6.4 隐藏通过上面的学习，我们已经知道，当子类覆写了父类的同名方法时，如果用子类实例化父类对象，会发生向上类型转换，这时调用该方法时，会自动调用子类的方法，这是实现多态的基础， 参见范例8-22。但是，在某些场景下，我们不希望父类的方法被子类方法覆写，即子类实例化后会调用父类的方法，而不是子类的方法，这种情况下该怎么办？这就需要用到另外一个概念——隐藏（hide）。被关键词static修饰的静态方法是不能被覆盖的，Java就是利用这一个特性达到隐藏的效果。请观察下面的范例。 范例8-25 隐藏子类的成员（HideSubClass.java） 　 class Father 　 { 　　 public static void overWritting() 　　 { 　　　　System.out.println(\"#######--Father method\"); 　　 } 　 } 　 class Son extends Father 　 { 　　 public static void overWritting() 　　 { 　　　　System.out.println(\"*****--Son method\"); 　　 } 　 } 　 public class HideSubClass 　 { 　　 public static void main(String args[]) 　　 { 　　　　Father dad = new Son(); 　　　　dad.overWritting(); 　　　　 　　　　Father.overWritting(); 　　　　Son.overWritting(); 　　 } 　 } 保存并运行程序，结果如下图所示。 代码详解第01~07行，定义了父类Father，里面定义了一个静态方法overWritting()。 第08~14行，定义了子类Son，它继承父类Father，在这个子类中，也定义了一个与父类同名的静态方法overWritting()。 第19行用子类实例化一个父类对象dad。第20行调用dad的overWritting()方法，从运行结果可以看出，这时调用的父类的方法没有被子类所覆盖，这就是说父类“隐藏”了子类的同名方法。而事实上，所有的静态方法都隶属于类，而非对象。所以，可以通过“类名.静态方法名”的方法来直接访问静态方法，如代码第22~23行所示。 从运行结果可以看出，在这样的情况下，“父类”与“子类”之间的方法就不会存在谁隐藏谁的问题。在Java中，“隐藏”概念的应用并不广泛，读者了解这个概念即可。 8.7 高手点拨 方法重载（Overload）和覆写（Override）的区别（本题为常见的Java面试题）重载是指在相同类内定义名称相同，但参数个数（或类型，或顺序）不同的方法，而覆写是在子类当中定义名称、参数个数和类型均与父类相同的方法，用于覆写父类中的方法。具体的区别如下表所示。 区别 重载 覆写 英语单词 Overload Override 定义 法名称相同、参数的类型及个数和顺序至少一个不同 方法名称、参数的类型及个数、返回值类型完全相同 范围 只发生在一个类之中 发生在类的继承关系中 权限 不受权限控制 被覆写的方法不能拥有比父类更严格的访问控制权限 在重载的关系之中，返回值类型可以不同，语法上没有错误，但是从实际的应用而言，建议返回值类型相同。 this和super的区别（本题为常见的Java面试题） 区别 this super 查找范围 先从本类找到属性或方法，本类找不到再查找父类 不查询本类的属性及方法，直接由子类调用父类的指定属性及方法 调用构造 this调用的是本类构造方法 由子类调用父类构造 特殊 表示当前对象 ---- 因为this和super都可以调用构造方法，所以this()和super()语法不能同时出现，两者是二选一的关系。 final关键字的使用 final在Java之中称为终结器，在Java之中final可以修饰3类情况：修饰类、修饰方法及修饰变量。使用final修饰的类不能有子类（俗称“太监”类）。 如果父类的方法不希望被子类覆写，可在父类的方法前加上final关键字，这样该方法便不会有被覆写的机会。 使用final定义的方法不能被子类所覆写。在父类中，将方法设置final类型的操作，实际编程时用途并不广泛，但是在一些系统架构方面会出现得比较多，这里读者知道有这类情况存在即可。 使用final定义的变量就成为了常量。常量必须在其定义的时候就初始化（即给予赋值），这样用final修饰的变量就变成了一个常量，其值一旦确定后，便无法在后续的代码中再做修改。一般来说，为了将常量和变量区分开来，常量的命名规范要求全部字母采用大写方式表示。 面向对象编程PK面向过程编程（续） 在第6章中，我们进行了面向对象编程与面向过程编程的比较。从上面的比较中，面向过程编程（POP）会认定，面向对象编程（OOP）的代码很笨拙，原因很简单，因为同样类似的代码，如Rotate()和PlaySong()，在3个不同的类中重复写了三遍，一点也不简洁。 但这样的认知并没有反映OOP的全貌，因为OOP的代码复用（Code Reuse）反映在“继承”上，在这一章，我们刚好学习完毕OOP的继承特性，我们再来“会会”POP。 现在我们假设再添加一个多边形，让它也具有Rotate()和PlaySong()特征，但是由于多边形的旋转和唱歌特性，完全不同于前3个图形，这样，POP继续添加它的else if语句，补充新代码。 OOP也添加了一个新的多边形类。需要注意的是，POP修改的代码是影响全局的。如果产品经理招聘过来一个新的员工，让他来维护过往的代码（即仅有3个图形类别的旧代码），那么这个新来的员工，就必须在“吃透”所有旧代码的基础上，完成功能的更新，但我们很难确保他会成功，他成功则罢，一旦失败，原来代码已经完成的功能也难以确保。反过来，对于OOP编程而言，由于这4个类的代码在功能上的确具有很大的相似性，因此，我们可以发挥抽象的特质，把这4个类“提炼”出来一个父类Shape，然后这4个类继承于父类，如下图所示。 由上图可知，在OOP中，我们可以设计基类来“凝练共识”，然后让子类复用基类代码。由于矩形、圆形和三角形是规则图形，它们的Rotate( )和PlaySong( )是通用的，那么矩形、圆形和三角形这3个子类，可以从父类“图形”那里直接继承父类中的两个方法，而无需添加额外的代码，这才是真正的代码简洁！如果把Rotate( )和PlaySong( )想象为成千上万行代码的汇集，这种代码的复用带来的简洁更是“叹为观止”。但是问题来了，POP会质疑，对于“不规则图形”，它的Rotate( )和PlaySong( )不同于父类，OOP无法复用父类的方法，怎么办？这难不倒OOP，因为在子类“不规则图形”中，我们可以利用“覆写（override）”父类的方法，来达到完成子类中比较有个性化特性的方法。更重要的是，OOP可以用“多态”的概念完成同一个接口，多个性化操作，显得更加简洁化。如下图所示，在这个代码图中，其核心地方可以用8个字形容：“指哪打哪”“统一接口”。具体来说，父类可以通过向上类型转换达到“指哪打哪”，父类对象可以指向它的每一个子类对象，然后用户可用“统一接口”来完成不同子类个性化功能的调用，这减轻了用户的开发和维护负担。这样看来，OOP似乎大胜POP了！但“大胜”并不代表“完胜”，客观来讲，任何事情都有两面性，在某种应用场景下，OOP付出的代价是，其执行效率并不如POP高。 8.8 实战练习 1.建立一个人类（Person）和学生类（Student），功能要求如下。 （1）Person中包含4个数据成员：name、addr、sex和age，分别表示姓名、地址、性别和年龄。设计一个输出方法talk()来显示这4种属性。 （2）Student类继承Person类，并增加成员Math、English存放数学与英语成绩。用一个六参构造方法、一个两参构造方法、一个无参构造方法和覆写输出方法talk()用于显示6种属性。对于构造方法参数个数不足以初始化4个数据成员时，在构造方法中采用自己指定的默认值来实施初始化。 2.观察下面的两个类，请回答下面的问题（本题改编自华为科技有限公司面试题）。 （1）在子类中哪些方法隐藏了父类的方法? （2）在子类中哪些方法覆盖了父类的方法?并通过编程实践验证上述问题。 class classA {　　 void methodOne(int i) { System.out.println(\"ClassA: methodOne, i = \" + i); } 　　 void methodTwo(int i){ System.out.println(\"ClassA: methodTwo, i = \" + i); } 　　 static void methodThree(int i){ System.out.println(\"ClassA: methodThree, i = \" + i); } 　 static void methodFour(int i){ System.out.println(\"ClassA: methodFour, i = \" + i); }　 }　 class classB extends classA {　　 static void methodOne() { System.out.println(\"ClassB: methodOne, i = \" + i); } 　 　 void methodTwo(int i){ System.out.println(\"ClassB: methodTwo, i = \" + i); } 　 void methodThree(int i){ System.out.println(\"ClassB: methodThree, i = \" + i); } 　 　 static void methodFour(int i){ System.out.println(\"ClassB: methodFour, i = \" + i); } } 3.定义一个Instrument（乐器）类，并定义其公有方法play()，再分别定义其子类Wind（管乐器），Percussion（打击乐器），Stringed（弦乐器），覆写play方法，实现每种乐器独有的play方式。最后在测试类中使用多态的方法执行每个子类的play()方法。 "},"java13.html":{"url":"java13.html","title":"凝练才是美--抽象类 接口 内部类","keywords":"","body":"凝练才是美——抽象类、接口与内部类 抽象类、接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。正是由于这些机制的存在，才赋予Java强大的面向对象的能力。本章讲述抽象类的基本概念、具有多继承特性的接口和内部类。 本章要点（已掌握的在方框中打钩） 熟悉抽象类的使用 掌握抽象类的基本概念 掌握抽象类实例的应用 掌握接口的基本概念 熟悉Java 8中接口的新特性 熟悉接口实例的应用 熟悉内部类的使用 在前面的章节中，我们反复强调一个概念：在Java面向对象编程领域，一切都是对象，并且所有的对象都是通过“类”来描述的。但是，并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，还需要其他具体的类来支撑它，那么这样的类我们称为抽象类。比如new Person( )，但是这个“人类”——Person( )具体长成什么样子，我们并不知道。他/她没有一个具体人的概念，所以这就是一个抽象类，需要一个更为具体的类，如学生、工人或老师类，来对它进行特定的“具体化”，我们才知道这人长成啥样。 9.1 抽象类 9.1.1 抽象类的定义 Java中有一种类，派生出很多子类，而自身是不能用来产生对象的，这种类称为“抽象类”。抽象类的作用有点类似于“模板”，其目的是要设计者依据它的格式来修改并创建新的子类。 抽象类实际上也是一个类，只是与之前的普通类相比，内部新增了抽象方法。所谓抽象方法，就是只声明而未实现的方法。所有的抽象方法必须使用abstract关键字声明，而包含抽象方法的类就是抽象类，也必须使用abstract class声明。 抽象类定义规则如下。抽象类和抽象方法都必须用abstract关键字来修饰。抽象类不能直接实例化，也就是不能直接用new关键字去产生对象。在抽象类中定义时抽象方法只需声明，而无需实现。含有抽象方法的类必须被声明为抽象类，抽象类的子类必须实现所有的抽象方法后，才能不叫抽象类，从而可以被实例化，否则这个子类还是个抽象类。 abstract class 类名称　　　　　　// 定义抽象类 {　 声明数据成员 ； 　 访问权限 返回值的数据类型 方法名称（参数…） 　 {　　　 // 定义一般方法 　 ｝　 abstract 返回值的数据类型 方法名称（参数…）；　 // 定义抽象方法，在抽象方法里没有定义方法体　 } 例如以下形式。 abstract class Book　　　　　　// 定义一个抽象类 {　　 private String title = \"Java开发\" ; // 属性　 public void print()　 {　　　　　　　　　 // 普通方法，用“{}”表示有方法体　　 System.out.println(title) ;　 } 　 public abstract void fun() ; 　　 // 没有方法体，是一个抽象方法 } 由上例可知，抽象类的定义只是比普通类多了一些抽象方法的定义而已。虽然定义了抽象类，但是抽象类却不能直接使用。 Book book = new Book() ;　　// 错误: Book是抽象的; 无法实例化 9.1.2 抽象类的使用 如果一个类可以实例化对象，那么这个对象可以调用类中的属性或方法，但是抽象类中的抽象方法没有方法体，没有方法体的方法无法使用。 所以，对于抽象类的使用原则如下。 抽象类必须有子类，子类使用extends继承抽象类，一个子类只能够继承一个抽象类。 产生对象的子类，则必须实现抽象类之中的全部抽象方法。也就是说，只有所有抽象方法不再抽象了，做实在了，才能依据类（图纸），产生对象（具体的产品）。 如果想要实例化抽象类的对象，则可以通过子类进行对象的向上转型来完成。 提示 在Java中，当子类继承父类时，子类可由此得到父类的方法。但不愿“墨守成规”的子类，可在子类中重新改写继承于父类的同名方法，我们称这个过程为覆盖重写，简称覆写（override）。 从抽象类的设计理念可知，抽象类生来就是被继承的。在其内的抽象方法通常是没有方法体的，因为有了也没用，抽象方法的本意就是期望其“子孙后代”类重新定义这个方法，并赋予新的内涵。这样一来，虽然在Java英文文档中依然用“override”来表明子类重新定义来自父类的抽象方法，但如果还将“override”翻译为“覆写”，就达不到“信达雅”的要求。 六祖惠能大师有句名言：“本来无一物，何处惹尘埃。” 在这里，我们也可说一句：“本无方法体，何处来覆写。” 因此，在本书中，对抽象类和接口中的抽象方法，在其子类中给予具体定义时，我们用“实现”而非“覆盖”来描述这个过程。用“实现”，相当于在子类中，将来自父类的抽象方法“给予”生命。这样可能更有韵意。 范例9-1 抽象类的用法案例（AbstractClassDemo.java） 　abstract class Person　　 //定义一抽象类Person 　{ 　　 String name ; 　　 int age; 　　 String occupation ;　 　　 public abstract String talk( ) ; // 声明一抽象方法talk( ) 　} 　class Student extends Person　 // Student类继承自Person类 　{ 　　 public Student(String name,int age,String occupation) 　　 { 　　　this.name = name ; 　　　this.age = age ; 　　　this.occupation = occupation ; 　　 } 　　 　　 @Override 　　 public String talk( )　// 实现talk( )方法 　　 { 　　　return \"学生——&gt;姓名：\" + name+\"，年龄：\" + age+\"，职业：\" + occupation ; 　　 } 　} 　class Worker extends Person　 // Worker类继承自Person类 　{ 　　 public Worker(String name,int age,String occupation) 　　 { 　　　 this.name = name ; 　　　 this.age = age ; 　　　 this.occupation = occupation ; 　　 } 　　 public String talk()　 // 实现talk( )方法 　　 { 　　　 return \"工人——&gt;姓名：\" + name + \",年龄：\" + age + \",职业:\" + occupation ; 　　 } 　} 　public class AbstractClassDemo 　{ 　　 public static void main(String[] args) 　　 { 　　　 Student s = new Student(\"张三\",20,\"学生\"); //创建Student类对象s 　　　 Worker w = new Worker(\"李四\", ,\"工人\"); //创建Worker类对象w 　　　 System.out.println(s.talk( )) ;　　　 //调用被实现的方法 　　　 System.out.println(w.talk( )) ; 　　 } 　} 程序运行结果如下图所示。 代码详解 第01~07行声明了一个名为Person的抽象类，在Person中声明了3个属性和一个抽象方法——talk( )。 第08~22行声明了一个Student类，此类继承自Person类，因为此类不为抽象类，所以需要“实现”Person类中的抽象方法——talk( )。 类似的，第23~35行声明了一个Worker类，此类继承自Person类，因为此类不为抽象类，所以需要“实现”Person类中的抽象方法——talk( )。 第40行和第41行分别实例化Student类与Worker类的对象，并调用各自的构造方法初始化类属性。 因为Student类与Worker类继承自Person类，所以Person类的数据成员name、age和occupation，也会自动继承到Student类与Worker类。 因此这两个类的构造方法，需要初始化这3个数据成员。第42行和第43行分别调用各自类中被实现的talk( )方法 【范例分析】可以看到Student和Worker两个子类都分别按各自的要求，在子类实现了talk( )方法。上面的程序可由下图表示。抽象类的特征如下所示。 （1）抽象类中可以拥有构造方法。 与一般类相同，抽象类也可以拥有构造方法，但是这些构造方法必须在子类中被调用，并且子类实例化对象的时候依然满足类继承的关系，先默认调用父类的构造方法，而后再调用子类的构造方法，毕竟抽象类之中还是存在属性的，但抽象类的构造方法无法被外部类实例化对象调用。 范例9-2 抽象类中构造方法的定义使用（AbstractConstructor.java） 　 abstract class Person　　　　　　　　　//定义一抽象类Person 　{ 　　String name ;　　 　　int age ; 　　String occupation ; 　　public Person(String name,int age,String occupation) //定义构造函数 　　{ 　　　this.name = name ; 　　　this.age = age ; 　　　this.occupation = occupation ; 　　} 　　 public abstract String talk() ;　 //声明一个抽象方法 　 } 　class Student extends Person　　//声明抽象类的子类 　{ 　　public Student(String name,int age,String occupation)　 　　{ // 在这里必须明确调用抽象类中的构造方法 　　　super(name,age,occupation); 　　} 　　public String talk()　　　　 // 实现talk()方法 　　{ 　　return \"学生——&gt;姓名：\" + name + \"，年龄：\" + age + \"，职业：\" + occupation; 　　} } 　class AbstractConstructor 　{ 　　public static void main(String[] args) 　　{ 　　　Student s = new Student(\"张三\",18,\"学生\") ;//创建对象s 　　　System.out.println(s.talk()) ; //调用实现的方法 　　} 　} 保存并运行程序，结果如下图所示。 代码详解第01~13行声明了一个名为Person的抽象类，在Person中声明了3个属性、一个构造函数和一个抽象方法——talk( )。 第14~24行声明了一个Student类，此类继承自Person类，因为此类不为抽象类，所以需要在子类中实现Person类中的抽象方法——talk( )。 第18行，使用super( )方法，显式调用抽象类中的构造方法。 第29行实例化Student类，建立对象s，并调用父类的构造方法初始化类属性。 第30行调用子类中实现的talk( )方法。 【范例分析】从程序中可以看到，抽象类也可以像普通类一样，有构造方法、一般方法和属性，更重要的是还可以有一些抽象方法，需要子类去实现，而且在抽象类中声明构造方法后，在子类中必须明确调用。 （2）抽象类不能使用final定义，因为使用final定义的类不能有子类，而抽象类使用的时候必须有子类，这是一个矛盾的问题，所以抽象类上不能出现final定义。 （3）抽象类之中可以没有抽象方法，但即便没有抽象方法的抽象类，其“抽象”的本质不会发生变化，所以也不能够直接在外部通过关键字new实例化。 9.2 接口 9.2.1 接口的基本概念 对C语言有所了解的读者就会知道，在C语言中，有种复合的数据类型——structure（结构体），结构体可视为纯粹是把一系列相关数据汇集在一起（the collections of data），比如说，我们可以把“班级”“学号”“姓名”“性别”“成绩”等数据属性，构成一个名为“学生”的结构体。 Java提供了一种机制，把对数据的通用操作（也就是方法），汇集在一起（the collections of common operation），形成一个接口（interface），以形成对算法的复用。 所谓算法，就是一系列相关操作指令的集合。 接口，是Java所提供的另一种重要技术，它可视为一种特殊的类，其结构和抽象类非常相似，是抽象类的一种变体。 在Java 8之前，接口的一个关键特征是，它既不包含方法的实现，也不包含数据。 换句话说，接口内定义的所有方法，都默认为abstract，即都是“抽象方法”。 现在，在Java 8中，接口的规定有所松动，它内部允许包括数据成员，但这些数据必须是常量，其值一旦被初始化后，是不允许更改的，这些数据成员通常为全局变量。 所以，当我们在一个接口定义一个变量时，系统会自动把“public ”“static”“final”这3个关键字添加在变量前面，如以下代码所示。 public interface faceA{　 int NORTH = 1;}上面的代码等效为以下代码。 public interface faceA{　public static final int NORTH = 1;}接口的设计宗旨在于，定义由多个继承类共同遵守的 “契约”。 所以接口中的所有成员，其访问类型都必须为public，否则不能被继承，就失去了“契约”内涵。 为了避免在接口中添加新方法后而要修改所有实现类，同时也是为了支持Lambda新特性的引入，从JDK 8开始，Java的接口也放宽了一些限制，接口中还可以“有条件”地对方法进行实现。 例如，允许定义默认方法（即default方法），也可称为Defender方法。 default方法是指，允许在接口内部实现一些默认方法（也就是说，在接口中可以包含方法体，这打破了Java 8版本之前对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。 在Java中使用interface关键字来定义一个接口。 接口定义的语法如下所示。 interface 接口名称　// 定义接口{　 final 数据类型 成员名称 = 常量 ；　// 数据成员必须赋初值　 abstract 返回值的数据类型 方法名称（参数…）；// 抽象方法，抽象方法没有方法体　 default 返回值的数据类型 方法名称（参数…）// 默认方法，包含方法体　 {　　 …方法体…　 }}接口的定义范例如下所示。 interface B // 定义一个接口B {　　 public static final String INFO = \"Hello World .\" ;　// 全局常量，public、static、final可省略　 public abstract void print() ;　　　　　　 // 抽象方法　 default public void otherprint()　　　　　// 带方法体的默认方法　 {　　　　 　　 System.out.println(\"default methods!\");　　　//默认方法的方法体　 } } 虽然定义了接口，但在所定义的接口A和接口B中，因接口内存在抽象方法，因此这些接口都不能被用户直接使用，必须在其子类中“实现”这些抽象方法，把“抽象的”方法“务实”了，变为实实在在的可用方法，才可以用之实例化对象。 9.2.2 使用接口的原则使用接口时，注意遵守如下原则。 接口必须有子类，子类依靠implements关键字可以同时实现多个接口。 接口的子类（如果不是抽象类）必须实现接口之中的全部抽象方法，才能实例化对象。 利用子类实现对象的实例化，接口可以实现多态性。 接口与一般类一样，本身也拥有数据成员与方法，但数据成员一定要赋初值，且此值不能再更改，方法也必须是“抽象方法”或default方法。 也正因为接口内的方法除default方法外必须是抽象方法，而没有其他一般的方法，所以在接口定义格式中，声明抽象方法的关键字abstract是可以省略的。 同理，因接口的数据成员必须赋初值，且此值不能再被更改，所以声明数据成员的关键字final也可省略。 简写的接口定义范例如下。 interface A // 定义一个接口 {　　 public static String INFO = \"Hello World .\" ;　// 全局常量　 public void print() ;　　　　　　　 // 抽象方法　 default public void otherprint()　 {　　　　　　　　　　　 // 带方法体的默认方法　　 System.out.println(\"default methods!\");　　 } } 在Java中，由于禁止多继承（通俗来讲，就好比一个“儿子”只能认一个“老爸”），而接口做了一点变通，一个子类可以“实现”多个接口，实际上，这是“间接”实现多继承的一种机制，这也是Java设计中的一个重要环节。 既然接口中除了default方法，只能有抽象方法，所以这类方法只需声明，而无需定义具体的方法体，于是自然可以联想到，接口没有办法像一般类一样，用它来创建对象。 利用接口创建新类的过程称为接口的实现（implementation）。 以下为接口实现的语法。 class 子类名称 implements 接口A,接口B… // 接口的实现{…}范例9-3 带default方法接口的实现（Interfacedefault.java） 　interface InterfaceA　　　　　　　　　　// 定义一个接口 　{　 　　 public static String INFO = \"static final.\" ; // 全局常量 　　 public void print( ) ;　　　　　　　　// 抽象方法 　　 　　 default public void otherprint( )　　　　 // 带方法体的默认方法 　　 { 　　　 System.out.println(\"print default1 methods InterfaceA!\"); 　　 } 　} 　 　class subClass implements InterfaceA　　 //子类InterfaceA实现接口InterfaceA 　{ 　　 public void print( )　　　　　　 //实现接口中的抽象方法print( ) 　　 { 　　　 System.out.println(\"print abstract methods InterfaceA!\"); 　　　 System.out.println(INFO); 　　 } 　} 　public class Interfacedefault 　{ 　　 public static void main(String[ ] args) 　　 { 　　　 subClass subObj = new subClass( );　　 //实例化子类对象 　　　 subObj.print( );　　　　　　　 //调用“实现”过的抽象方法 　　　 subObj.otherprint( );　　　　　　 //调用接口中的默认方法 　　　 System.out.println(InterfaceA.INFO);　　//输出接口中的常量 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解第01~10行定义接口InterfaceA，其中定义全局静态变量INFO、抽象方法print()及默认方法otherprint()。 第12~19行定义子类subClass，实现接口InterfaceA，“实现”从接口InterfaceA继承而来的方法print()。 第24行实例化子类对象，并调用在子类实现的抽象方法（第25行）和默认方法（第26行），输出接口InterfaceA的常量INFO（第27行）。 【范例分析】上例中定义了一个接口，接口中定义常量INFO，省略了关键词final，定义抽象方法print()；，也省略了Abstract，定义带方法体的默认方法。 第17行和第27行分别引用接口中的常量。 在Java 8中，允许在一个接口中只定义默认方法，而没有一个抽象方法，下面举例说明。 范例9-4 仅有default方法接口的使用（InterfacedefaultOnly.java） 　interface InterfaceA　　　　　　　 // 定义一个接口 　{　 　　 default public void otherprint( )　　// 带方法体的默认方法 　　 { 　　　 System.out.println(\"print default1 methods only in InterfaceA!\"); 　　 } 　} 　class subClass implements InterfaceA　　 //子类subClass实现接口InterfaceA 　{　 　　 //do nothing 　} 　public class InterfaceDefaultOnly 　{ 　　 public static void main(String[ ] args) 　　 { 　　　 subClass subObj = new subClass( );　//实例化子类对象　 　　　 subObj.otherprint();　　　　　　 //调用接口中的默认方法　　 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解第01~07行定义接口InterfaceA，其中定义默认方法otherprint()。 第08~11行定义子类subClass，实现接口InterfaceA。 第16~17行实例化子类对象subObj，并调用由接口InterfaceA继承而来的默认方法otherprint()。 【范例分析】由于接口InterfaceA中并无抽象方法，因此无抽象方法需要在子类中“实现”，所以子类subClass的主体部分什么也没有做，但这部分的工作是必需的，因为接口是不能（通过new操作）实例化对象的，即使子类subClass什么也没有做，其实也实现了一个功能，即由subClass可以实例化对象。 接口与抽象类相比，主要区别就在于子类上，子类的继承体系中，永远只有一个父类，但子类却可以同时实现多个接口，变相完成“多继承”，如下例所示。 范例9-5 子类继承多个接口的应用（InterfaceDemo.java） 　interface faceA　 // 定义一个接口 　{ 　　 public static final String INFO = \"Hello World!\" ; // 全局常量 　　 public abstract void print( ) ; // 抽象方法 　} 　interface faceB　 // 定义一个接口 　{　 　　 public abstract void get( ) ; 　} 　class subClass implements faceA,faceB 　{　 // 一个子类同时实现了两个接口 　　 public void print( ) 　　 { 　　　 System.out.println( INFO ) ; 　　 } 　　 public void get( ) 　　 { 　　　 System.out.println(\"你好！\") ; 　　 } 　} 　public class InterfaceDemo 　{ 　　 public static void main(String args[]) 　　 { 　　　 subClass subObj = new subClass() ; // 实例化子类对象 　　　 　　　 faceA fa = subObj ;　// 为父接口实例化 　　　 fa.print() ; 　　　 　　　 faceB fb = subObj ;　// 为父接口实例化 　　　 fb.get() ; 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解第01~05行定义接口faceA，其中定义全局变量INFO和抽象方法print()。 第06~09行定义接口faceB，并定义了抽象方法get( )。 第10~20行定义子类subClass，同时实现接口faceA和faceB，并分别对接口faceA和faceB中的抽象方法进行实现。 【范例分析】由上例可以发现接口与抽象类相比，主要区别就在于子类上，子类可以同时实现多个接口。 但在Java 8中，如果一个类实现两个或多个接口，即“变相”的多继承，但是若其中两个接口中都包含一个名字相同的default方法，如下例中的faceA和faceB中有同名的默认方法DefaultMethod( )，但方法体不同。 范例9-6 同时实现含有两个相同默认方法名的接口（Interfacsamedefaults.java） 　interface faceA　　　　　　 //定义接口faceA 　{　 　　 void someMethod( ); 　　 default public void DefaultMethod( )//定义接口中的默认方法 　　 { 　　　 System.out.println(\"Default method in the interface A\"); 　　 } 　} 　interface faceB　　　　　　 //定义接口faceB 　{ 　　 default public void DefaultMethod( )//定义接口InterfaceB中同名的默认方法 　　 { 　　　 System.out.println(\"Default method in the interface B\"); 　　 } 　} 　class DefaultMethodClass implements faceA,faceB //子类同时实现接口faceA和faceB 　{　public void someMethod( )　　　　　 //实现接口InterfaceA的抽象方法 　　{ 　　　 System.out.println(\"Some method in the subclass\");　 　　 }　 　} 　public class Interfacsamedefaults 　{　 　　 public static void main(String[] args) 　　 {　 　　　 DefaultMethodClass def = new DefaultMethodClass( ); 　　　 def.someMethod();　　　　 //调用抽象方法 　　　 def.DefaultMethod();　　　　//调用默认方法 　　 } 　} 保存程序并运行，编译并不能通过，如下图所示。 代码详解代码第01~08行定义了一个接口faceA，其中定义抽象方法someMethod( )和默认方法DefaultMethod( )，请注意，someMethod( )前面的public和abstract关键字可以省略，这是因为在接口内的所有方法（除了默认类型方法），都是“共有的”和“抽象的”，所以这两个关键字即使省略了，“智能”的编译器也会替我们把这两个关键字加上。 代码第09~15行定义了另外一个接口faceB，其中定义了一个和接口faceA同名的默认方法DefaultMethod( )，其实这两个默认方法的实现部分并不相同。 第16~21行定义了子类DefaultMethodClass，同时实现接口faceA和faceB，并对接口faceA 中的抽象方法someMethod( )给予实现。 代码第26行，实例化子类DefaultMethodClass的对象。 【范例分析】如果编译以上代码，编译器会报错，因为在实例化子类DefaultMethodClass的对象时，编译器不知道应该在两个同名的default方法——DefaultMethod中选择哪一个（Duplicate default methods named DefaultMethod），因此产生了二义性。 因此，一个类实现多个接口时，若接口中有默认方法，不能出现同名默认方法。 事实上，Java之所以禁止多继承，就是想避免类似的二义性。 但在接口中允许实现默认方法，似乎又重新开启了“二义性”的灾难之门。 在“变相”实现的多继承中，如果说在一个子类中既要实现接口，又要继承抽象类，则应该采用先继承后实现的顺序完成。 范例9-7 子类同时继承抽象类，并实现接口（ExtendsInterface.java） 　interface faceA 　{　 // 定义一个接口 　　 String INFO = \"Hello World.\" ; 　　 void print( ) ; // 抽象方法 　} 　interface faceB 　{　// 定义一个接口 　　 public abstract void get( ) ; 　} 　abstract class abstractC 　{ // 抽象类 　　 public abstract void fun( ) ;　 // 抽象方法 　} 　class subClass extends abstractC implements faceA,faceB 　{ // 先继承后实现 　　 public void print( ) 　　 { 　　　 System.out.println(INFO) ; 　　 } 　　 public void get( ) 　　 { 　　　 System.out.println(\"你好！\") ; 　　 } 　　 public void fun( ) 　　 { 　　　 System.out.println(\"你好！JAVA\") ; 　　 } 　} 　public class ExtendsInterface 　{ 　　 public static void main(String args[]) 　　 { 　　　 subClass subObj = new subClass( ) ; // 实例化子类对象 　　　 faceA fa = subObj ;　// 为父接口实例化 　　　 faceB fb = subObj ;　// 为父接口实例化 　　　 abstractC ac = subObj ;　// 为抽象类实例化 　 　　　 fa.print() ; 　　　 fb.get() ; 　　　 ac.fun(); 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解第01~05行声明了一个接口faceA，然后在里面声明了1个常量INFO并赋初值\"Hello World.\"，同时定义了一个抽象方法print( )。 第06~09行声明了一个接口faceB，在其内定义了一个抽象方法get()。 第10~13行声明抽象类abstractC，在其内定义了抽象方法fun()。 第14~28行声明子类subClass，它先继承（extends）抽象类B，随后实现（implements）接口faceA和faceB。 第33行实例化了子类subClass的对象subObj。 第34~35行实现父接口实例化。 第36行实现抽象类实例化。 【范例分析】如果我们非要“调皮地”把第14行代码，从原来的“继承在先，实现在后”，如下所示。 class subClass extends abstractC implements faceA,faceB改成“实现在先，继承在后”，如下所示。 class subClass implements faceA,faceB extends abstractC编译器是不会答应的，它会报错，如下图所示。 9.2.3 接口的作用——Java的回调机制回调（callback）是Java中很重要的一个概念，在后面章节讲解的Spring、Hibernate等计算框架中，都大量使用了回调技术，所以有必要了解一下这个机制。 在设计模式中，有个较新的模式，叫控制反转（Inversion of Control，IoC），它是一个重要的面向对象编程的法则，用来削减计算机程序的耦合问题，也是轻量级的Spring框架的核心。 由于概念相对较新，在Erich Gamma等四人组合著的《Design Patterns》（设计模式）中，并没有体现这一模式。 控制反转的本质，就是Java中的回调机制。 “回调”，其英文“call back”的原意是“回电话”，这最早源于“好莱坞原则（Hollywood principle）”：“Don't call me, we will callyou（不要给我打电话，我们会打给你）”。 也就是说，如果好莱坞明星想演节目，不用自己去找好莱坞公司，而是由好莱坞公司主动去找他们（当然，之前这些明星必须要在好莱坞登记过）。 言外之意，虽然我们之间有通电话的需求，但是我们会在需要的时候，再确定下来通电话的对象。 在某些面向过程（事件驱动）的编程语言（如C语言）中，开发人员可以通过传递函数指针（function pointer）直接实现回调机制，回调的对象可能是一段代码块（方法块）。 但Java作为一门面向对象的编程语言，并不支持方法指针（method pointer，在Java中，方法的地位等同于C中的函数），所以想实现回调机制，必须通过“对象（object）”来完成，这似乎妨碍了回调机制的完成。 Java“关上了一扇门，必然会为你开启另一扇窗”，而这扇窗就是“接口”。 在Java中，回调流程通常要从声明一个接口开始。 下面我们举例说明。 范例9-8 Java回调机制的演示（Caller.java） 　interface CallBack 　{ 　　 void methodToCallBack( ); 　} 　class CallBackImpl implements CallBack 　{ 　　 public void methodToCallBack( ) 　　 { 　　　 System.out.println(\"I'\"ve been called back\"); 　　 } 　} 　public class Caller 　{ 　　 public void register(CallBack callback) 　　 { 　　　 callback.methodToCallBack( ); 　　 } 　　 public static void main(String[] args) 　　 { 　　　 Caller caller = new Caller( ); 　　　 CallBack callBack = new CallBackImpl( ); 　　　 caller.register(callBack); 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解第01~04行，声明了一个接口CallBack，在这个接口中声明了一个抽象方法methodToCallBack( )。 第05~11行，用一个名为CallBackImpl的类，实现了接口CallBack。 第12~24行，设计了一个主调类Caller，其中第14~17行声明了一个注册方法register()，特别需要注意的是，这个方法的参数是接口对象CallBack的引用。 第20行，新建了一个Caller对象，第21行新建了一个CallBackImpl的对象，它是接口CallBack的具体实现者。 第22行，调用注册方法register()，实参就是CallBackImpl的对象callBack，因为CallBackImpl实现（某种程度上可以说是继承）了抽象接口，所以在register()方法中，callBack可以调用methodToCallBack()方法。 或许，读者会困惑，为什么不在第21行之后这么做。 callback.methodToCallBack()这样岂不是更加简便？的确如此。 但这段代码不在于如何用最短的代码实现具体功能，而是为了给我们展示一下，如何在Java环境下实现一个回调机制。 我们知道，回调机制的真正意图，其实是为了实现“控制反转（Inversion of Control）”。 通过控制反转，对象在被创建的时候（如第21行），由一个能够调控系统内所有对象的外界实体（如第20行的caller），将其所依赖的对象的引用传递给功能方法块（如第22行的callBack，被送入到register()中）。 我们知道，同一个接口，可以有不同的实现类，从而使得这些不同的实现类，可以定义众多不同的对象，而这些对象会被按需“注入”功能方法块register()。 在被调用前，这些对象永远处于等待调用状态，直到有一天被回调（callback）。 由上分析可知，控制反转可以用来降低计算机代码之间的耦合度。 在控制反转的设计模式提出之后，引起了很大的关注和争议。 于是，资深程序员马丁 ● 福勒（Martin Fowler）发表了一篇经典文章《Inversionof Control Containers and the Dependency Injection pattern》（控制容器的反转和依赖注入模式），终于算是平息了争论。 于是，“控制反转”又获得了一个新的名字：“依赖注入 （Dependency Injection）”。 “依赖注入”的确更加准确地描述了这种设计理念。 所谓依赖注入，就是指组件之间的依赖关系由容器在运行期决定，在注入之前，对象之间的耦合关系是松散的。 下面，我们再列举一个更加实用的案例，来说明Java中的回调机制。 范例9-9 利用接口实现Java中的回调机制（callBackDemo.java） 　import java.awt.Rectangle; 　interface Measurer 　{ 　　 double measure(Object anObject); 　} 　class AreaMeasurer implements Measurer 　{ 　　 public double measure(Object anObject) 　　 { 　　　 Rectangle aRectangle = (Rectangle) anObject; 　　　 double area = aRectangle.getWidth() * aRectangle.getHeight(); 　　　 return area; 　　 } 　} 　class Car 　{ 　　 private double price; 　　 private double taxRate; 　　 Car(double price, double taxRate) 　　 { 　　　 this.price = price; 　　　 this.taxRate = taxRate; 　　 } 　　 public double getPrice() 　　 { 　　　 return price; 　　 } 　　 public double getRate() 　　 { 　　　 return taxRate; 　　 } 　} 　class CarMeasurer implements Measurer 　{ 　　 public double measure(Object anObject) 　　 { 　　　 Car aCar = (Car) anObject; 　　　 double totalPrice = aCar.getPrice() * (1 + aCar.getRate()); 　　　 return totalPrice; 　　 } 　} 　class Data 　{ 　　 public static double average(Object[] objects, Measurer meas) 　　 { 　　　 double sum = 0.0; 　　　 for (Object obj : objects) 　　　 { 　　　　　sum = sum + meas.measure(obj); 　　　 } 　　　 if (objects.length &gt; 0) 　　　 { 　　　　　return sum / objects.length; 　　　 } else { 　　　　　return 0; 　　　 } 　　 } 　} 　public class callBackDemo 　{ 　　 public static void main(String[] args) 　　 { 　　　 Measurer areaMeas = new AreaMeasurer(); 　　　 Rectangle[] rects = new Rectangle[] 　　　 { 　　　　　new Rectangle(5, , , ), 　　　　　new Rectangle( , , , ), 　　　　　new Rectangle( , , 5, ) 　　　 }; 　　　 double averageArea = Data.average(rects, areaMeas); 　　　 System.out.println(\"平均面积为: \" + averageArea); 　　　　　　 　　　 Measurer carMeas = new CarMeasurer(); 　　　 Car[] cars = new Car[] 　　　 { 　　　　　new Car( 0, 0. ), 　　　　　new Car( 0, 0. ), 　　　　　new Car( 0, 0. ), 　　　 }; 　　　 double averagePrice = Data.average(cars, carMeas); 　　　 System.out.println(\"平均价格为: \"+ averagePrice);　　 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解在第02~05行，声明了如下一个测量器的接口Measurer，在这个接口里，声明了一个measure( )方法，很明显，这是一个抽象方法，只有方法声明，而没有实现方法体。 此外，还应该注意到，在这个measure方法内，测量的是某个对象（Object），这个对象到目前为止，并不明确。 不明确的用意在于，先不绑定任何特定的对象。 第06~14行，通过AreaMeasurer类来实现（implement）Measurer接口。 这时，把抽象的方法measure( )具体化，把抽象的对象明确化（Rectangle aRectangle = (Rectangle) anObject），才能使用。 需要注意的是，在Java的继承体系中，由于Object对象是所有对象的“鼻祖”，因此，Object对象可以“化身”为任何类型对象的引用。 第42~58行，定义了一个Data类，这个类负责求某个对象属性的均值。 但需要注意的是，这个方法average( )所代表的算法，和其操作的对象是松耦合的。 因为这个average( )方法的第一个参数是抽象的对象（Object）类型数组，第二个参数是抽象的测量接口Measurer类型。 其特别之处在于，把求均值这个方法和求均值的对象暂时分割开（也可以认为是解耦）。 随后，当我们遇到对象是矩形，那么我们就求矩形面积的均值（第06~14行）。 如果后期我们遇到对象是汽车，那么我们就求这些汽车售价的均值（第15~41行）。 显然，这种延后确定对象，之后“有的放矢”地求均值机制，让这个方法更具有一般性和通用性。 虽然求均值的方法是一样的：各对象值求和/对象个数。 但不同的对象，有不同的测量方法，而这些不同的个性化测算方法，则是来自于对接口Measurer的不同实现版本，即不同的对象，实现不同版本的measure( )方法。 第06~14行显示的是矩形的测算方法，而第33~41行则显示的求汽车价格的测算方法。 【范例分析】上面代码中第63行，明确测量的对象为面积测量，第64~69行定义一些列的矩形对象。 然后调用Data类的静态方法average( )，实参rects（矩形对象数组）给这个方法中的第一个参数——形参objects赋值，第二个参数的实参areaMeas，实际上是一个面积测量的对象，被赋值给形参meas。 前面涉及几个类和接口之间的UML关系，如下图所示。 类似的，第73行，明确测量的对象为计算汽车销售价格均值，第74~79行定义一些列的矩形对象（即对象数组）。 然后调用average( )方法，实参cars（汽车对象数组），给这个方法中的第一个参数——形参objects赋值，第二个参数的实参carMeas，实际上是一个价格计算的对象，被赋值给形参meas。 由上分析可知，Data类中的average( )方法，从Rectangle、Car等类中解耦出来。 Rectangle类和Car类，也不再和其他类耦合，取而代之的是，我们提供了一个诸如AreaMeasure、CarMeasure等小助手（即接口Measurer的一个具体实现）。 这个助手类存在的唯一目的，就是告诉average方法，如何来测量对象的某种属性值的平均值。 我们知道，控制反转关注的是，一个对象如何获取他所依赖的对象的引用，这是责任的反转。 请读者参照范例9-8，分析一下，在范例9-9中，控制反转（或者是角色注入）体现在什么地方呢？ 9.3 内部类 所谓的内部类，就是指在一个类的内部又定义了其他类。 如果在类Outer的内部再定义一个类Inner，此时类Inner就称为内部类，而类Outer则称为外部类。 内部类可声明为public或private。 当内部类声明为public或private时，对其访问的限制与成员变量和成员方法完全相同。 9.3内部类的名称不需要和.java文件相同。 9.3.1 内部类的基本定义内部类的定义格式如下所示。 标识符 class 外部类的名称{　 // 外部类的成员　 标识符 class 内部类的名称 　 {　　 // 内部类的成员 　 }}内部类主要有如下作用。 （1）内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。 （2）内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，同一个类的成员之间可以相互访问。 但外部类不能访问内部类的实现细节，例如，内部类的成员变量。 （3）匿名内部类适合用于创建那些仅需要一次的类。 范例9-10 内部类的使用（ObjectInnerDemo.java） 　class Outer 　{ 　　 int score = ; 　　 void inst() 　　 { 　　　 Inner in = new Inner(); 　　　 in.display();　　 　　 } 　　 public class Inner 　　 { 　　 // 在内部类中声明一个name属性 　　　 String name = \"张三\"; 　　　 void display() 　　　 {　　　　 　　　　　System.out.println(\"成绩: score = \" + score);//输出外部类中的属性 　　　 } 　　 } 　} 　public class ObjectInnerDemo 　{ 　　 public static void main(String[] args) 　　 { 　　　 Outer outer = new Outer(); 　　　 outer.inst(); 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解第04~08行声明了一个inst()方法，用于实例化内部类的对象in。 第09~17行，在Outer类的内部声明了一个Inner类，此类中有一个display()方法，用于打印外部类中的score属性。 【范例分析】从程序中可以看到，内部类Inner可以直接调用外部类Outer中的score属性，现在如果把内部类拿到外面来单独声明，那么在使用外部类Outer中的score属性时，则需要先产生Outer类的对象，再由对象通过点操作（“.”），调用Outer类中的公有接口（也就是公有方法），然后再由这些公有接口“间接”地访问score属性。 由此可以看到，由于使用了内部类操作，程序在访问score属性的时候，减少了创建对象的操作，从而省去了一部分的内存开销。 需要读者注意的是，内部类是一个编译时的概念，一旦编译成功，事实上，就会生成完全不同的两个类（类个数总和取决于内部类的个数加上外部类个数）。 对于一个名为Outer的外部类和名为Inner的内部类，编译完成后出现Outer.class和Outer$Inner.class两个类，以及包含主方法的测试类ObjectInnerDemo，如上图所示，其中Outer$Inner.class就是一个编译好的内部类，而“$”就表示隶属关系。 在运行时需要注意的是，只能用java 来解析含有主方法的类ObjectInnerDemo。 9.3.2 在方法中定义内部类内部类不仅可以在类中定义，也可以定义在方法体或作用域内（即由“｛｝”括起来的区域）。 这样的内部类作用范围仅局限于方法体或特定的作用域内，因此也称为局部内部类。 下面举例说明。 范例9-11 在方法中定义内部类（ObjectInnerClass.java） 　class InnerClassTest 　{ 　　 int score = ; 　　 void inst( ) 　　 { 　　　 class Inner 　　　 { 　　　　　void display( ) 　　　　　{ 　　　　　　 System.out.println(\"成绩: score = \" + score); 　　　　　} 　　　 } 　　　 Inner in = new Inner( ); 　　　 in.display( ); 　　 } 　} 　public class ObjectInnerClass 　{ 　　 public static void main(String[] args) 　　 { 　　　 InnerClassTest outer = new InnerClassTest(); 　　　 outer.inst( ); 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解在InnerClassTest类中的第04~15行声明了一个inst( )方法，在此方法中又声明了一个名叫Inner的内部类，同时产生了Inner的内部类实例化对象（第13行），调用其内部的方法display( )（第14行）。 第21行产生了一个InnerClassTest类的实例化对象outer，并在第22行调用Outer类中的inst( )方法。 【范例分析】在命令行下运行Java程序，可以显示更多细节，如下图所示。 像上一个类一样，编译完成后出现多个类，而且只能用java来解析含有主方法的类ObjectInnerClass。 像其他类一样，局部内部类也可以进行编译，所不同的是，作用域不同而已，局部内部类只在该方法或条件的作用域内才能使用，出了这些作用域后，便无法引用。 读者可以把局部内部类想象成一个普通的数据类型，普通的数据类型在某个方法体内或作用域内，定义了一个局部变量，出了它所定义的作用域范围，它的生命周期就到头了，其他地方自然也就无法引用它。 9.4 匿名内部类 有时候，我们懒得去给内部类命名，这时就倾向于使用匿名内部类。 因为匿名内部类没有名字，所以它的创建方式也比较特别。 创建格式如下所示。 new 父类构造器（参数列表）|实现接口(){ //匿名内部类的类体部分 }这里，我们可以看到，使用匿名内部类，我们必须要继承一个父类或实现一个接口。 需要注意：①匿名内部类是没有class关键字做修饰的；② 匿名内部类是直接使用new来生成一个对象的引用。 在new之前，这个匿名内部类是要先定义的。 范例9-12 匿名内部类使用实例（AnonymousInnerClass.java） 　abstract class Bird 　{ 　　 private String name; 　　 public String getName() 　　 { 　　　 return name; 　　 } 　　 public void setName(String name) 　　 { 　　　 this.name = name; 　　 } 　　 public abstract int fly(); 　} 　 　public class AnonymousInnerClass 　{ 　　 public void birdBehaviour(Bird bird) 　　 { 　　　 System.out.println(bird.getName() + “最高能飞 \" + bird.fly() + \"米\"); 　　 } 　　 public static void main(String[] args) 　　 { 　　　 AnonymousInnerClass AnonyObjObj = new AnonymousInnerClass(); 　　　 AnonyObjObj.birdBehaviour(new Bird() 　　　　　{ 　　　　　　 public int fly() 　　　　　　 { 　　　　　　　 return 1000; 　　　　　　 } 　　　　　　 public String getName() 　　　　　　 { 　　　　　　　 return \"小鸟\"; 　　　　　　 } 　　　　　}); 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解代码第01~13行，定义了一个抽象类Bird，里面有个仅有方法声明而无方法体的抽象方法——fly( )。 根据前面学习到的知识，我们知道，如果抽象类Bird内部的抽象方法没有具体化，永远都是抽象类，没有办法用new关键字，创建一个实例。 第17行，在birdBehaviour方法的参数列表中，bird仅仅作为方法体的形参——也就是形式上的参数，换句话说，它天生就是来接纳实参（实际上的参数）来赋值的，所以参数列表中并不涉及生成新对象。 在第23行，生产一个AnonymousInnerClass类的对象AnonyObjObj。 接着，重点来了，在第24行，对象AnonyObjObj使用自己类的公有方法birdBehaviour( )，此刻，这个方法的参数要做实了，它需要一个实实在在的Bird对象。 而我们知道，Bird本身还是一个抽象类，想定义对象，必须先把这个类中的抽象方法变得不抽象（也就是设计实现部分）。 假设这个抽象类的非抽象化仅仅就用一次，那么这个类定义出来的实例对象叫什么名字也无所谓，索性就不给它取名字，用一个匿名类好了。 于是，在第25~35行，实际上，就重新定义了抽象类，主要目的还是让抽象方法fly( )不再抽象了。 然后，第24行用new 操作，创建了一个无名小鸟bird，当作实参，传递给birdBehaviour( )。 由此可以看到，第24~35行代码的目的就是要生产出来一个“一次性”的、用完就扔的Bird类实例而已。 但因为这种“偷懒”的方法，让代码的可读性变得较差，所以并不推荐。 请读者思考，在这个范例中，如何改成可读性较好的非匿名类实现同样的功能？提示匿名内部类存在一个缺陷，就是它仅能被使用一次，创建匿名内部类时，它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类不能够被重复使用。 9.5 匿名对象 匿名对象，顾名思义，就是没有明确的声明的对象。 读者也可以简单地理解为只使用一次的对象，即没有任何一个具体的对象名称引用它。 请看下面的范例。 范例9-13 匿名对象的使用（AnonymousObject.java） 　class Person 　{ 　　 private String name = \"张三\"; 　　 private int age = ; 　　 public String talk( ) 　　 { 　　　 return \"我是：\" + name + \"，今年：\" + age + \"岁\"; 　　 } 　} 　public class AnonymousObject 　{ 　　public static void main(String[] args) 　　 { 　　　 System.out.println(new Person( ).talk( )); 　　 } 　} 保存并运行程序，结果如下图所示。 代码详解第01~09行声明了一个Person类，里面有name和age两个私有属性，并分别赋了初值。 第14行声明了一个Person匿名对象，通过“new Person( )”产生一个匿名对象，然后再通过“对象.方法名”的Java语法格式，调用Person类中的talk( )方法。 【范例分析】从程序中可以看到，用“new Person( )”声明的对象，它并没有赋给任何一个Person类对象的引用，所以此对象只使用了一次，用完之后，就会被Java的垃圾收集器回收。 现在总结一下匿名对象的特点。 （1）匿名对象不会被其他对象所引用。 （2）匿名对象是“一次性（disposable）”的对象产品，使用一次就变成垃圾了，被垃圾回收器收回了。 有意思的是，英文单词中的“disposable”，有“可任意处理的”和“用完即可丢弃的”这两层含义，都可以用于形容“匿名对象”。 9.6 高手点拨 继承一个抽象类和继承一个普通类的主要区别（1）在普通类之中所有的方法都是有方法体的，如果说有一些方法希望由子类实现的时候，子类即使不实现，也不会出现错误。 而如果重写改写了父类的同名方法，就构成了“覆写”。 （2）如果使用抽象类的话，那么抽象类之中的抽象方法，在语法规则上就必须要求子类给予实现，这样就可以强制子类做一些固定操作。 接口不能实例化对象我们可以声明一个接口对象的变量（引用），假设我们定义一个接口faceA 。 interface faceA // 定义一个接口A {　　 void doSomething( ); } 下面的定义是合法的。 faceA myface;但是，我们不能用接口构造一个对象，如下代码是错误的。 faceA myface = faceA( );// 错误原因很简单，接口不是一个类，接口中的方法基本上都是抽象的，所以不能用它构造（通过new操作）一个对象。 但一个接口变量（即引用）却可以指向它的子类对象（也就是通过“实现”这个接口的类的对象），如下所示。 class myClass implements faceA // 定义一个接口A {　　 @Override　 void doSomething( )　 {　　 Doing something;　 }　 void doNewSomething( )　 {　　 Doing new thing;　 } } faceA myface = new myClass(); //正确，但只能访问myClass从接口faceA“实现”的方法 接口、抽象类、类、对象的关系（1）基本类：也就是一般的类（一般所说的类就是基本类），是对象的模板，是属性和方法的集合。 可以继承其他的基本类（继承一个）、抽象类（继承一个）、实现接口（实现多个）。 （2）抽象类：有抽象方法的类(抽象方法就是该方法必须由继承来实现，本身只定义，不实现)。 抽象类可以有一个或多个抽象方法，它是基本类和接口类的过渡。 （3）接口：接口中的所有方法除默认方法（带方法体）外都是抽象方法，抽象方法本身只定义，不实现，用来制定标准。 四者间的关系如下图所示。 实际上，所谓的接口就是指在类的基础上的进一步抽象（抽离数据，保留行为）。 而很多时候在开发之中，也会避免抽象类的出现，因为抽象类毕竟存在单继承的局限。 类与类之间的共性就成了接口的定义标准。 类、抽象类、接口之间的角色扮演，可以用如下的例子来做类比。 比如说，在一个公司里，有老板、老板聘用的经理和员工3种角色。 普通类就好比是员工，抽象类就好比是经理，接口就好比是老板。 在接口里，“老板”就是动动嘴皮子，光提方法，但他自己不去实现。 比如，老板说我要那个文件，给我定个机票，我要那个策划方案等，都是手下的人去实现。 在抽象类中，它给出的方法，有的是他自己做，有的是其他人做（即继承于它这个类的子类）。 比如经理说我要那个文档，员工就要发给他，但是他自己也要做点事，比如拿方案给老板看。 一言蔽之，经理（抽象类）需要又说又做。 相比而言，普通类“脚踏实地”，自己给出的方法要非常具体，什么都要实现，亲力亲为。 接口和抽象类的应用抽象类（abstract）在Java语言中体现了一种继承关系，要想使继承关系合理，父类和派生类之间必须存在“IS A”关系，即父类和派生类在概念本质上应该是相同的。 对于interface 来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。 考虑这样一个例子，假设建立一个关于Door的抽象概念，一般认为Door可执行两个动作：open和close，若通过abstract class或interface来定义一个表示该抽象概念的类型，定义方式分别如下所示。 使用abstract 类方式定义Door。 abstract class Door { 　 abstract void open(); 　 abstract void close(); } 使用interface方式定义Door。 interface Door { 　 void open(); 　 void close(); } 其他具体子类，比如说子类——木门类（WoodDoor）或铁门类（IronDoor）等可以通过extends（扩展）继承抽象类Door中定义的两个方法open()和close()。 类似地，木门类或铁门类也可以通过关键字implements，同样继承使用接口Door中的两个方法。 这样看起来，使用abstract class和interface好像没有太大的区别。 事实上，并非如此。 比如说，如果用户的需求发生变化，现在要求所有的Door都要具备报警的功能，那该如何设计这个类结果呢？解决方案一简单地在抽象类Door中新增加一个alarm的方法如下所示。 abstract class Door { 　 abstract void open(); 　 abstract void close(); 　 abstract void alarm(); //新添加一个抽象方法 } 那么，具有报警功能的子类AlarmDoor继承上述变更的父类即可，具体代码如下所示。 class AlarmDoor extends Door { 　 void open() { … } //实现继承而来的方法open()　 void close() { … } //实现继承而来的方法close ()　 void alarm() { … } //实现继承而来的方法alarm () } 另外一种修改方式是利用interface实现，如下所示。 interface Door { 　 void open(); 　 void close(); 　 void alarm(); //新添加一个报警接口alarm } 那么，具有报警功能的子类AlarmDoor通过implements继承接口添加新方法，具体代码如下所示。 class AlarmDoor implements Door ｛ 　 void open() { … } 　 void close() { … } 　 void alarm() { … } ｝ 然而，直接在抽象类或接口中新增加alarm方法，其实是违反了面向对象设计中的一个核心原则——接口隔离原则（Interface Segregation Principle，ISP）。 前面的行为，即把Door概念本身固有的行为方法（如close和open）和另外一个概念“报警器”的行为方法混在了一起。 这样就会引起一个问题，那些仅仅依赖于Door这个概念的模块，会因为抽象类（父类）“添加报警器”这个方法的改变而被迫改变，并不是所有的子类都需要报警功能的。 在一个接口中添加一个新方法，也会导致所有使用这个接口的子类被迫使用这个它可能不需要的方法。 此外，这种不断地在接口中添加新方法的策略，也会使原来的Door接口变得越来越“胖”，这就是所谓的“接口污染”。 解决方案二事实上，我们还有第二种方法。 显然，open、close和alarm属于两个不同的概念，前两个（open、close）是必备功能，而alarm是附加功能。 根据ISP原则，应该把它们分别定义在代表这两类概念的两个抽象类中。 定义的可能方式有3种。 （1）这两个概念都使用abstract class方式定义。 点评：因为Java语言不支持多重继承，所以两个概念都使用abstractclass方式定义是不可行的，因为其子类不可能同时继承“Door”和“Alarm”两个类，从而达成AlarmDoor功能的汇集。 （2）两个概念都使用interface方式定义。 点评：在概念本质上，无法明确体现AlarmDoor，到底是Door，还是报警器，无法反映AlarmDoor在概念本质上和Door是一致的。 （3）一个概念使用abstract class方式定义，另一个概念使用interface方式定义。 abstract class Door { 　 abstract void open(); 　 abstract void close()； } interface Alarm { 　 void alarm(); } class AlarmDoor extends Door implements Alarm { 　 void open() { … } 　 void close() { … } 　 void alarm() { … } } 点评：这是一个“中庸”的方案，比较符合我们的要求，在概念上继承了“Door”的所有特性，同时，又通过实现接口，在功能上完成了“扩展”。 抽象类在Java语言中表示一种继承关系，而继承关系在本质上是“is a”关系，对于Door这个概念，我们应该使用abstract class方式来定义。 interface表示的是“like a”关系，AlarmDoor又具有报警功能，说明它又能够完成报警概念中定义的行为。 9.7 实战练习 1.设计一个限制子类访问的抽象类实例，要求在控制台输出如下结果。 教师——>姓名：刘三，年龄：50，职业：教师工人——>姓名：赵四，年龄：30，职业：工人2.利用接口及抽象类设计实现。 （1）定义接口圆形CircleShape()，其中定义常量PI，默认方法area计算圆面积。 （2）定义圆形类Circle实现接口CircleShape，包含构造方法和求圆周长方法。 （3）定义圆柱继承Circle实现接口CircleShape，包含构造方法、圆柱表面积、体积。 （4）从控制台输入圆半径，输出圆面积及周长。 （5）从控制台输入圆柱底面半径及高，输出圆柱底面积、圆柱表面积及体积。 3.定义一个包含“name”“age”和“sex”的对象，使用匿名对象输出对象实例。 4.完成一个统计Book类产生实例化对象的个数。 "},"java14.html":{"url":"java14.html","title":"更灵活的设计--泛型","keywords":"","body":"更灵活的设计——泛型 JDK 5.0以后增加了泛型，泛型可以通过一种类型或方法操作各种不同的类型，其提供了编译时类型的安全性。 这是一个比较大的改动，甚至有些Java的API都进行了重写，泛型的引入方便了我们的开发。 通过本章的学习，读者将理解并掌握泛型的概念和使用方法，包括泛型类和泛型方法。 本章要点（已掌握的在方框中打钩）泛型概念泛型类、泛型方法和泛型接口泛型使用的限制泛型通配符泛型继承10.1 泛型的概念所谓泛型，就是允许在定义类、接口的时候指定类型形参（类型的形式参数的简称），这个类型形参将在声明变量、创建对象时确定，即传入实际的类型参数，也可称为类型实参，这实际上是将数据类型参数化。 泛型可以用来定义泛型类、泛型方法和泛型接口。 在JDK 5.0之后的代码中，如果定义了泛型，但是没有使用泛型的话，为了兼容之前版本的JDK，会给出一个警告错误，但不影响编译和运行。 范例10-1 JDK版本中有关泛型向下兼容的警告错误 　public class Base ; { 　　 T m; 　　 Base(T t) { 　　　 m = t; 　　 } 　 　　 public void print() { 　　　 System.out.println(\"base print ：\" + m); 　　 } 　} 　Base; base=new Base; 　Base; base1=new Base(\"aa\");第 行不会报警告错误，第 行会报“Base is a raw type”的错误。 .2 泛型类的定义泛型类的定义语法如下所示。 [访问修饰符] class 类名称&lt;T&gt;泛型类的定义主要作用在于在类被实例化后，方便传入具体的参数对类的成员属性和成员方法进行 替换。 范例10-2 泛型类定义 　　 T m; 　　 Base(T t) { 　　　 m = t; 　　 } 　　 public T getM(){ 　　　 return m; 　　 } 　　 public void print() { 　　　 System.out.println(\"base print ：\" + m); 　　 } 　　 public static void main(String[] args) { 　　　 Base; base=new Base;(\"base class is general\"); 　　　 System.out.println(base.getM()); 　　 } 　} 第01行定义了泛型类Base，并通过T来定义成员变量m，定义了getM方法的返回值和构造方法的参数t，13行实例了一个对象base，并传入String类作为T的类型，这个被称为泛型类的实例化，有点类似于类的实例化。 之后m、t的类型就变成了String，getM的返回值也是String。 其实，是把T作为参数来定义这几个变量的类型和方法的参数类型。 T可以用任何一种引用类型，但是不允许使用基本类型，如int、double、char、boolean等是不允许的。 类型类被定义后，可以使用T来定义其成员变量和成员方法的返回值与参数。 10.3 泛型方法的定义泛型方法主要用于容器类，Java中任何方法，包括静态的（注意，和泛型类不一样，泛型类不允许在静态环境中使用）和非静态的，均可以用泛型来定义，而且和所在类是否是泛型没有关系，下面是泛型方法的定义。 [public] [static] ; 返回值类型 方法名（T参数列表）范例10-3 泛型方法定义 　public class GeneralMethod {　　 　　　 public static ; void print(U[] list) { 　　　　　System.out.println(); 　　　　　for (int i = 0; i 输出结果如下所示。 a b c d e1 2 3 4 5使用泛型方法时，至少返回值或参数有一个是泛型定义的，而且应该保持一致，否则可能会受到各种限制，因此，这里建议保持一致。 10.4 泛型接口的定义接口也可以定义为泛型的，语法如下所示。 [public] interface ;范例10-4 泛型接口定义 　public class GeneralInterface { 　　 public static void main(String[] args) { 　　　　System.out.println(new TestIBase().getA()); 　　 } 　} 　interface IBase;{　 　　public T getA(); 　 public T getB(); 　} 　class TestIBase implements IBase;{　 　　public String getA() {　　 　　　　return \"A\"; 　　} 　　public String getB() {　 　　　　return \"B\"; 　　　 }　 　} 按照泛型接口的语法规定，不能在接口中使用泛型来定义成员属性，下面的定义方法是不被允许的，这一点和泛型类是不同的。 　interface IBase;{　 　　 T m; 　　 public T getA(); 　　 public T getB(); 　} 第02行会报“Cannot make a static reference to the non-static typeT”错误，这表示在接口中直接定义泛型成员属性是不被允许的。 10.5 泛型的使用限制和通配符的使用在泛型的使用过程中，有些情况是不能使用泛型的，有时开发者对泛型实例化也想进行一些限制，这些都可以通过泛型的使用限制来完成，尽管它们是有限的。 另外，在泛型的定义过程中，还可以使用通配符来提高泛型定义的灵活性。 10.5.1 泛型的使用限制这里泛型的使用限制有两种含义：其一是什么情况下不能使用泛型，其二是开发者想限制泛型的实例化过程。 以下几种情况泛型是不被允许的。 （1）不能使用泛型的形参创建对象。 下面的语句是错误的。 T o=new T();（2）不能在静态环境中使用泛型类的类型参数，下面的用法是错误的。 public class A;{　 public static T t;//错误　 public T getA（）{//允许　 …　 }}（3）异常类不能是泛型的，换句话说，泛型类不能继承java.lang.Throwable类。 如类D的定义public class D ; extends java.lang.Throwable就是不被允许的。 （4）泛型不能初始化一个数组，但是可以声明数组。 下面的用法是错误的。 T [ ] b=new T[10];如果开发者想限制泛型的实例化，则可以通过下面的方法。 泛型类名;范例10-5 泛型类的实例化限制 　public class Base; { 　　　T m; 　　　Base(T t) { 　　　　　 m = t; 　　　} 　　　public T getM(){ 　　　　 return m; 　　　} 　　 public void print() { 　　　　　 System.out.println(\"base print ：\" + m); 　　　} 　　　public static void main(String[] args) { 　　　　　 B bb=new B(\"test B\"); 　　　　　 Base; base=new Base;(bb);//允许 　　　　　 Base; base=new Base;(\"base class is general\"); //不允许 　　　　　 System.out.println(base.getM()); 　　　} 　} 　class supA{ 　　　public String toString(){ 　　　　　 return \"supA\"; 　　　} 　} 　class B extends supA{ 　　　String b; 　　　public B(String b){ 　　　　　 this.b=b; 　　　} 　　　public String toString(){ 　　　　　 return \"subB\"; 　　　} 　} 通过T extends supA将泛型实例化的对象限制到必须是supA的子类，所以第14行是允许的，而第15行是不允许的。 supA可以是接口，但是extends不能换成implements，必须使用extends。 10.5.2 通配符的使用引入通配符可以在泛型实例化时更加灵活地控制，也可以用在方法中控制方法的参数。 语法如下所示。 泛型类名;或泛型类名;extends规定了“？”的上限，super规定了“？”的下限，还有一种做法是省略了extends，看起来是下面的形式。 泛型类名;这表示泛型实例化对象可以是任何允许的类型。 范例10-6 通配符在泛型类创建泛型对象中使用 　class gent ;{　 　} 　public class testa {　 　　　public static void main(String[] args) { 　　　　 gent ; o; 　　　　 o=new gent;();//正确 　　　　 o=new gent;();//错误 　　　}　 　} 第4行的o对象声明中“? extends String”决定了泛型的实例化对象只能是String类或它的子类，所以第 行正确，而第07行是错误的。 范例10-7 通配符在方法参数中的使用 　class supC{ 　　　public String toString(){ 　　　　　 return \"supA\"; 　　　} 　} 　class Bc extends supC{ 　　　String b; 　　public Bc(String b){ 　　　　　 this.b=b; 　　　} 　　　public String toString(){ 　　　　　 return \"subB\"; 　　　} 　　　public void test(gent; o){　　 　　} 　　　public static void main(String[] args) { 　　　　　 Bc bc=new Bc(\"test\"); 　　　　　 gent; oGent=new gent;(); 　　　　　 bc.test(oGent);　　 　　　} 　} 第14行定义了方法test的参数o，指明泛型参数必须是supC类或其子类，第19行是调用，oGent是supC的子类对象。 10.6 泛型的继承和实现泛型类和泛型接口被定义后，是可以被继承和实现的。 下面举例说明泛型类的继承和泛型接口的实现过程。 范例10-8 泛型类的继承 　public class A;{ 　　　E t; 　} 　public class B; extends A;{ 　　　 　} 子类B在定义的时候，如果省略了A后的;，那么B的T自动变成Object，建议定义时加上;以保留父类的类型参数。 B类还可以增加新的泛型T1。 范例10-9 泛型接口的实现 　interface IT;{ 　　　public T dis(); 　} 　public class testIT; implements IT;{ 　　　E e; 　　　public testIT(E e){ 　　　　　 this.e=e; 　　　} 　　　public E dis() {　　 　　　　　 return e; 　　　} 　　　public static void main(String[] args){ 　　　　　 testIT; tt=new testIT;(\"test\"); 　　　　　 System.out.println(tt.dis()); 　　　} 　} 实现类testIT不能省略;，必须和普通实现类一样，实现IT接口中的所有方法。 10.7 高手点拨1.泛型的使用大大增加了程序设计的灵活性，必要时，方法的名字可以用泛型替代，如下所示。 　public class SupGent { 　　 public class A;{ 　　　　 E t; 　　　　 public A(E t){ 　　　　　　 this.t=t; 　　　　 } 　　　　 public E E(){ 　　return t; 　　　　 } 　　 } 　　 public class B; extends A;{ 　　　　 public B(E t){ 　　super(t); 　　　　 } 　　　} 　　　public static void main(String[] args){　 　　　　　SupGent.B; b=(new SupGent()).new B;(\"test\"); 　　　　　System.out.println(b.E()); 　 　　　} 　} 第07行采用了泛型E，碰巧方法的名字也是E，只不过不要弄混，上例输出结果为test。 2.在进行数据库DAO封装操作时，采用泛型可以简化开发。 　public class BaseDAO ;{ 　　 public void Save(T t){　} 　　 public void Del(T t){　} 　　 public void Update(T t){　} 　　 public void Search(T t){　} 　} 　class TeacherDao extends BaseDAO;{ 　　 public void Save(Teacher t){　} 　　 public void newOperator(Teacher t){　} 　} 　class StudentDao extends BaseDAO;{ 　　 public void Save(Student t){　} 　　 public void newOperator2(Student t){　} 　} 　class Teacher{} 　class Student{}BaseDAO定义了基本的数据库增删改查，之后可以继承该泛型类，实现各自的增删改查，或者使用超类的增删改查，同时每个继承类还可以增加自己的操作。 10.8 实战练习参照高手点拨中的第2题，完善例子中的代码，实现教师或学生的增删改查，尝试给TeacherDao、StudentDao增加新的数据库操作。 "},"java15.html":{"url":"java15.html","title":"更强大和方便的功能--注解","keywords":"","body":"更强大和方便的功能——注解JDK 5.0以后增加了注解，注解不但增强了程序编写的方便性，而且程序员可以通过反射机制，完成对编程信息的访问。 本章介绍注解的用法、自定义注解、通过反射访问注解及通过注解生成注释等内容。 本章要点（已掌握的在方框中打钩）注解概述常用内置注解自定义注解通过反射访问注解11.1 注解概述注解（Annotation），或叫注释，是JDK 1.5以后引入的注释的语法，但是它却区别于普通的注释，普通的代码注释通过“//”或“/…./”即可完成注释。 注解除了具备简单的注释功能外，更多的可以完成“配置”式的编程。 通过注解可以配置一些编程的元数据，比如对类、方法、变量、属性等的声明，通过注解的声明可以在编译时、类加载时和运行时实现对这些声明的访问，从而完成更加灵活的程序设计。 实际上，注解是一种接口定义，通过该接口定义，再利用Java的反射机制来完成其信息的访问。 一般来讲，通过JDK内置的Annotation和自定义的Annotation主要可以完成以下几个功能。 控制JavaDoc文档的生成。 跟踪代码的依赖性，实现配置式编程。 运行时访问编程元数据。 编译时实现格式检查。 注解被广泛应用到各种开发环境中，目前流行的开发框架SSH（Struts、Spring、Hibernate）中就大量地使用了注解，比如在Spring的开发配置中，既可以通过编写XML配置文件来实现各种Bean的管理和注入，同时可以利用注解的方式，直接在编程时实现Bean的声明和注入，这些实际上就是利用注解和反射机制，访问了编程元数据来实现的。 本章接下来讲解一下JDK内置的一些常用注解用法，自定义注解方法和注解较为复杂的一些用法。 11.2 常用内置注解在JDK 5.0中，内置了一些注解，通过这些注解方便我们对程序的控制和编写，方便JavaDoc的输出控制。 内置注解分为两类，一类是元注解，另一类是普通注解。 所谓的元注解就是对注解的注解，这个我们在本章的自定义注解小节讲解，下面主要介绍普通注解。 常见的普通注解有@Override、@Deprecate、@SuppressWarnings等。 注解的特殊使用方法就是必须在关键字前面加上“@”，无论是内置注解还是自定义注解均是这样。 @Override注解用来告诉编译器，@Override声明的方法是覆盖超类方法的。 @Deprecate注解告诉编译器本方法不建议使用。 @SuppressWarnings注解用来抑制警告信息的显示。 @Documented注解则用来将自定义的注解设置成文档说明。 下面一一举例说明。 范例11-1 通过@Override覆盖超类方法 package chapter; 　public class ch11_1 { 　 　 public void test(){ 　 　　 System.out.println(\"ok\"); 　 　 } 　} 　class subCh11_1 extends ch11_1{ 　 　 @Override 　 　 public void Test(){ 　 　　System.out.println(\"ok\"); 　 　 } 　 } 代码详解第09行的本意是要覆盖超类ch11_1的方法test，但是名字Test的首字母写成了大写，这样就无法实现对超类方法的覆盖，因为覆盖必须方法名相同，返回值相同，参数也相同。 这时候可以加上第08行的@Override注解，该注解指明Test方法是对超类方法的覆盖，因此编译器会检查是否有覆盖错误。 本例编译通不过，只有把Test的首字母改成小写后，方可运行。 范例11-2 通过@SuppressWarnings关闭警告信息 package chapter11; 　public class ch11_2 { 　　 public static void main(String args[]){ 　 　　 @SuppressWarnings(\"unused\") 　 　　 int a; 　 　　 String bString=\"ok\"; 　 　　 System.out.println(\"@SuppressWarnings description\"); 　 　 } 　 } 代码详解第05行和第06行分别定义了2个局部变量，编译时，第06行会报一个警告错误“The value of the local variable bString is not used”，意思是说本地变量bString虽然定义了却没有被使用，这个警告错误是不影响运行的，为了避免出现这种错误提示，可以像第04行一样，加入@SuppressWarnings(\"unused\")注解，这样就可以避免警告错误的提示。 @SuppressWarnings可以标注在类、字段、方法、参数、构造方法，以及局部变量上，除了unused外，还可以用unchecked、serial、deprecation等忽略对应的警告信息。 范例11-3 通过@Deprecate告知编译器被标注的元素是不希望被使用的 package chapter11; 　public class ch11_3 { 　 　 public static void main(String[] args) { 　 　　 ch11_3_1.test1(); 　 　　 ch11_3_1.test2(); 　 　 } 　} 　class ch11_3_1{ 　 　 @Deprecated 　 　 public static void test1(){ 　 　　 System.out.println(\"test1 method is deprecated\"); 　 　 } 　 　 public static void test2(){ 　 　　 System.out.println(\"test1 method is pray\"); 　 　 } } 代码详解第09行加入@Deprecated注解后，第04行调用时，系统会弹出警告信息，告知test1方法已经不再使用了。 JDK为了兼容老版本的API，很多方法都加入了@Deprecated，使用这些老的方法时都会提示警告信息，但不影响运行。 11.3 自定义注解自定义注解允许开发者开发自己的注解，从而实现更加灵活和复杂的编程思想。 自定义注解的语法如下所示。 [public] @interface 自定义注解的名称{ [数据类型 变量名称();]}注意@interface的写法，必须加上“@”，另外就是注解的变量声明，每个变量后面加上“()”，定义注解时，一般还要指明注解的作用范围，通过@Retention注解来指明，也就是说@Retention 注解时定义注解的注解，我们称为元注解，常见的元注解有@Target、@Retention、@Documented、@Inherited。 因此在定义注解时，往往配合元注解来丰富和完善注解的定义。 @Retention表示在什么级别保存该注解信息。 可选的参数值在枚举类型 RetentionPolicy中，该枚举类型的值如下表所示。 枚举值 说明 RetentionPolicy.SOURCE 注解将被编译器丢弃 RetentionPolicy.CLASS 注解在class文件中可用，但会被JVM丢弃 RetentionPolicy.RUNTIMEJVM 将在编译、加载、运行期均保留注解，因此可以通反射机制读取注解的信息｜ 若没有指定@Retention，默认的编译器认为@Retention 指定的是RetentionPolicy.CLASS。 @Target 表示该注解用于什么地方，可能的值在枚举类 ElemenetType中，如下表所示。 枚举值 说明 ElemenetType.CONSTRUCTOR 构造器声明 ElemenetType.FIELD 域声明（包括 enum 实例） ElemenetType.LOCAL_VARIABLE 局部变量声明 ElemenetType.ANNOTATION_TYPE 作用于注解量声明 ElemenetType.METHOD 方法声明 ElemenetType.PACKAGE 包声明 ElemenetType.PARAMETER 参数声明 ElemenetType.TYPE 类，接口（包括注解类型）或enum声明 @Documented 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。 在doc文档中的内容会因为此注解的信息内容不同而不同。 @Inherited 允许子类继承父类中的注解。 范例11-4 自定义注解TestAnnoaction0 package chapter11; 　@interface testAnnoation0{ 　 　 public String name() default \"methodname\"; 　 　 public String unit() default \"unit\"; 　} 　public class ch11_4 { 　 　 public static void main(String[] args) { 　 　 } 　 　 @testAnnoation0(name = \"电池SOC\", unit = \"%\") 　 　 public void testAnnoation(){ 　 　 } 　} 代码详解第02~05行自定义了一个注解testAnnoation0。 第03行指定了注解的属性name，默认值为字符串“methodname”。 第04行指定了注解的属性unit，默认值为字符串“unit”。 第09行使用了该注解，并将注解的name属性设置为“电池SOC”，unit的值为 “%”。 范例11-5 自定义注解TestAnnoation1，指定注解的作用对象 package chapter11; 　import java.lang.annotation.ElementType; 　import java.lang.annotation.Target; 　@Target(ElementType.METHOD) 　@interface testAnnoation1{ 　 　 public String name() default \"methodname\"; 　 　 public String unit() default \"unit\"; 　} 　public class ch11_5 { 　　 public static void main(String[] args) { 　 　 } 　 　 @testAnnoation1(name = \"电池SOC\", unit = \"%\") 　 　 public void testAnnoation(){ 　 　 } 　} 代码详解第05行指定了注解testAnnoation用于方法的声明。 如果用在非方法的元素上，比如成员属性，那么编译是通不过的。 范例11-6 自定义注解TestAnnoation2，并指定什么级别保存该注解信息 package chapter11; 　import java.lang.annotation.ElementType; 　import java.lang.annotation.Retention; 　import java.lang.annotation.RetentionPolicy; 　import java.lang.annotation.Target; 　@Retention(RetentionPolicy.RUNTIME) 　@Target(ElementType.METHOD) 　@interface testAnnoation2{ 　 　 public String name() default \"methodname\"; 　 　 public String unit() default \"unit\"; 　} 　public class ch11_6 { 　 　 public static void main(String[] args) { 　 　 } 　 　 @testAnnoation2(name = \"电池SOC\", unit = \"%\") 　 　 public void testAnnoation(){ 　 　 } 　} 代码详解第06行指定了注解testAnnoation的保留级别为RetentionPolicy.RUNTIME，这就意味着该注解在编译、加载、运行期均保留注解信息。 范例11-7 通过@Document控制JavaDoc的输出 package chapter11; 　import java.lang.annotation.Documented; 　import java.lang.annotation.ElementType; 　import java.lang.annotation.Retention; 　import java.lang.annotation.RetentionPolicy; 　import java.lang.annotation.Target; 　@Documented 　@Retention(RetentionPolicy.RUNTIME) 　@Target(ElementType.METHOD) 　@interface testAnnoation{ 　 　 public String name() default \"methodnam\"”; 　 　 public String unit() default \"unit\"; 　} 　public class ch11_7 { 　 　 public static void main(String[] args) { 　 　 } 　 　 @testAnnoation(name = \"电池SOC\", unit = \"%\") 　 　 public void testAnnoation(){ 　 　 } 　} 代码详解从第07~13行自定义了一个注解testAnnoation（关于如何自定义注解将在下一小节讲解），在第18行使用了该注解，注意如果在第07行不写@Documented注解，那么生成JavaDoc文档时，关于类ch11_4 中testAnnoation方法的说明如下。 细心的读者会发现，没有关于注解@testAnnoation的任何信息，但是当我们加上第07行的@Documented注解后，再生成的JavaDoc文档如下。 @testAnnoation注解信息显示出来了，也就是说@Documented在定义注解的时候，控制了是否在生成文档的时候生成有关注解的信息。 11.4 通过反射访问注解信息利用Java的反射机制，可以访问注解的信息。 比如在调用某个方法时，我们需要知道该方法的一些基本信息，而这些信息又需要动态获取时，利用反射获取注解信息是一个比较理想的处理方式，当然，我们直接了解某个类的某个方法的功能，了解返回数据的类型是较为常规的做法，但这种做法的前提是要先了解再调用。 反射首先要获取该类的类型信息，然后通过该类型信息就可以完成对注解信息的访问。 假设实例化的类名为ch8，获取类型信息如下。 Class class1=ch8.getClass();class1的getAnnotation方法和getAnnotations方法可以直接访问ch8类上的注解信息。 getAnnotation获取指定注解信息，getAnnotations获取所有注解信息。 通过Class1的getField方法访问ch8的成员属性，根据返回的Field类型的对象的getAnnotation方法和getAnnotations方法访问成员属性的注解信息。 通过Class1的getMethod方法访问ch8的成员方法，根据返回的Method类型的对象的getAnnotation方法和getAnnotations方法访问成员属性的注解信息。 范例11-8 访问类的某个成员方法的注解信息 package chapter11; 　import java.lang.annotation.Annotation; 　import java.lang.annotation.Documented; 　import java.lang.annotation.ElementType; 　import java.lang.annotation.Retention; 　import java.lang.annotation.RetentionPolicy; 　import java.lang.annotation.Target; 　import java.lang.reflect.Method; 　@Documented 　@Retention(RetentionPolicy.RUNTIME) 　@Target(ElementType.METHOD) 　@interface testAnnoation8{ 　 　 public String name() default \"methodname\"; 　 　 public String unit() default \"unit\"; 　} 　public class ch11_8 { 　 　 public String aString; 　 　 public static void main(String[] args) { 　 　　 try { 　 　　　 ch11_8 ch8=new ch11_8(); 　 　　　 Method method=ch8.getClass().getMethod(\"getData1\"); 　 　　　 Annotation ans[]=method.getAnnotations(); 　 　　　 for (Annotation annotation : ans) { 　 　　　　　 System.out.println(annotation); 　 　　　 } 　 　　　 Annotation annotation=method.getAnnotation(testAnnoation8.class); 　 　　　 System.out.println(annotation); 　 　　 } catch (Exception e) { 　 　　　　e.printStackTrace(); 　 　　 } 　 　 } 　 　 @Deprecated 　 　 @testAnnoation8(name = \"电池SOC\", unit = \"%\") 　 　 public void getData1(){ 　 　 } 　} 代码详解从第09~15行自定义了一个注解testAnnoation。 第16~36行定义了类ch11_8。 第32~35行定义方法getData1，方法上有两个注解@Deprecated和@testAnnoation8(name = \"电池SOC\", unit = \"%\")。 第20行定义了ch11_8的对象ch8。 第21行访问ch8的成员方法getData1。 第22~25行访问getData1方法上的所有注解。 第26~27行访问了指定注解testAnnoation8，注意指定注解传递的参数是testAnnoation8.class，也就是类的类型信息对象。 范例11-8的输出结果如下所示。 @java.lang.Deprecated()@chapter11.testAnnoation8(unit=%, name=电池SOC)@chapter11.testAnnoation8(unit=%, name=电池SOC)范例11-9 访问类的某个成员方法的注解信息 package chapter11; 　import java.lang.annotation.Annotation; 　import java.lang.annotation.Documented; 　import java.lang.annotation.ElementType; 　import java.lang.annotation.Retention; 　import java.lang.annotation.RetentionPolicy; 　import java.lang.annotation.Target; 　import java.lang.reflect.Method; 　@Documented 　@Retention(RetentionPolicy.RUNTIME) 　@Target(ElementType.METHOD) 　@interface testAnnoation9{ 　 　 public String name() default \"methodname\"; 　 　 public String unit() default \"unit\"; 　} 　public class ch11_9 { 　 　 public String aString; 　 　 public static void main(String[] args) { 　 　　 try { 　 　　　 ch11_9 ch9=new ch11_9(); 　 　　　 Method method=ch9.getClass().getMethod(\"getData1\"); 　 　　　 Annotation annotation=method.getAnnotation(testAnnoation9.class); 　 　　　 testAnnoation9 t9=(testAnnoation9)annotation; 　 　　　 System.out.println(\"name value is \"+t9.name()+\"; unit is \"+t9.unit()); 　 　　 } catch (Exception e) { 　 　　　　e.printStackTrace(); 　 　　 } 　 　 } 　 　 @Deprecated 　 　 @testAnnoation9(name = \"电池SOC\", unit = \"%\") 　 　 public void getData1(){ 　 　 } 　} 代码详解第23行将注解强制转换为testAnnoation9。 第24行访问了testAnnoation9注解的name属性和unit属性，并打印其值。 输出结果如下所示。 name value is 电池SOC; unit is %11.5 高手点拨当调用大量方法，且每个方法返回值和类型较多时，可以使用反射和注解简化编程。 我们对范例11-9进行改造，假设范例11-9的getData方法有很多，而且每个方法参数的个数和返回值都不同，如范例11-10所示。 范例11-10 访问类的某个成员方法的注解信息 package chapter11; 　import java.lang.annotation.Annotation; 　import java.lang.annotation.Documented; 　import java.lang.annotation.ElementType; 　import java.lang.annotation.Retention; 　import java.lang.annotation.RetentionPolicy; 　import java.lang.annotation.Target; 　import java.lang.reflect.Method; 　import java.util.ArrayList; 　 　@Documented 　@Retention(RetentionPolicy.RUNTIME) 　@Target(ElementType.METHOD) 　@interface testAnnoation10{ 　 　 public String name() default \"methodname\"; 　 　 public String unit() default \"unit\"; 　} 　public class ch11_10 { 　 public static void main(String[] args) throws Exception{ 　 　　ch11_10 ch9=new ch11_10(); 　 　　Method method[]=ch9.getClass().getMethods(); 　 　　for (Method method2 : method) { 　 　　　 Annotation annotation=method2.getAnnotation(testAnnoation10.class); 　 　　　 Class; ts[]=method2.getParameterTypes(); 　 　　　 if (method2.getName().indexOf(\"getData\")==-1) continue; 　 　　　 ArrayList; params=new ArrayList;(); 　 　　　 for (Class; class1 : ts) { 　 　　　　　if (class1.getSimpleName().equals(\"int\")){ 　 params.add(10); 　 　　　　　} 　 　　　　　if (class1.getSimpleName().equals(\"String\")){ 　 params.add(\"100\"); 　 　　　　　} 　 　　　 } 　 　　　 if (annotation!=null){ 　 　　　　　testAnnoation10 t9=(testAnnoation10)annotation; 　　 System.out.println(t9.name()+\" is \"+method2.invoke(ch9, params.toArray())+\" \"+t9.unit()); 　 　　　 } 　 　　 } 　 } 　 @testAnnoation10(name = \"SOC\", unit = \"%\") 　 public int getData1(int a){ 　 　　return a; 　 } 　 @testAnnoation10(name = \"Electricity\", unit = \"Ah\") 　 public String getData2(String b){ 　 　　return b; 　 } 　 @testAnnoation10(name = \"Tempreture\", unit = \"℃\") 　 public int getData3(int a,int b){ 　 　　return a+b; 　 } 　} 代码详解第11~17行定义了注解testAnnoation10。 第41~42行使用了注解testAnnoation10，并分别给每个注解的属性赋予了不同值，getData1是“SOC”，getData2是“Electricity”，getData3是“Tempreture”。 第21行获取ch9上的所有方法。 第23行获取每个方法上的testAnnoation10注解信息。 第24行获取每个方法的参数类型。 第27~32行给每个方法的参数赋值。 第37行利用注解信息，打印每个方法（getData1、getData2、getData3）执行的结果，注解中的name和unit是不同的。 输出结果如下所示。 SOC is 10 %Electricity is 100 AhTempreture is 20 ℃11.6 实战练习参照范例11-10，修改注解，使得调用者可以利用注解对方法进行分类，打印每个分类信息和每个分类下的方法及方法执行的结果。 （提示：给注解加上category属性，在使用注解的时候给每个category赋予类别值即可）。 "},"java4.html":{"url":"java4.html","title":"JavaWeb实战项目","keywords":"","body":" 整理实战JavaWeb项目 微人事项目实战 要点 微人事项目介绍 项目技术架构 前后端分离项目构建 登录模块实现 动态加载用户菜单 邮件发送 员工资料导入导出 在线聊天 前端项目打包 本章将通过一个前后端分离项目带读者掌握目前流行的Spring Boot+Vue前后端分离开发环境 的搭建以及项目的开发流程。本章重点向读者介绍前后端分离环境的搭建以及开发流程，也涉及少 量的业务逻辑。 本章项目的完整代码可以在GitHub上下载，下载地址为https://github.com/lenve/vi,本章在展示代码时仅展示项目关键步骤的核心代码。 项目简介 人事管理系统是一种常见的企业后台管理系统，它的主要目的是加强各个部门之间的协调提高工作效率。人事管理系统提供了员工资料管理、人事管理、工资管理、统计管理以及系统管理等功能，通过人事管理统，人事组织部门能做到以人为中心，各部门之间实现资源共享，并且实现即时通信，提高工作效率，简化烦琐的手工统计、信息汇总和工资业务等大量的人工工作，让人事组织和工资管理工作在人事组织相关的部门之间活跃起来。 技术架构 本项目采用当下流行的前后端分离的方式开发，后端使用 Spring Boot开发，前端使用Vue+ElementUI来构建SPA.SPA 是指 Single-Page Application,即单页面应用，SPA应用通过动 本重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。在SPA中，所有的HTML、JavaScript和CSS都通过单个页面的加载来检索，或者根据用户操作动态装载适当的资源并添加到页面。在SPA中，前端将通过Ajax与后端通信。对于开发者而言，SPA最直观的感受就是项目开发完成后，只有一个 HTML页面，所有页面的跳转都通过路由进行导航。前后端分离的另一个好处是一个后端可以对应多个前端，由于后端只负责提供数据，前后端的交互都是通过JSON数据完成的，因此后端开发成功后，前端可以是PC端页面，也可以是Android、iOS以及微信小程序等。 系统设计 Vue简介 Vue(读音／vju:/,类似于 view)是一套用于构建用户界面的渐进式框架。与其他大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 完全能够为复杂的单页应用提供驱动。－Vue 官网 对于Vue的基础知识，本书不做过多介绍，由于Vue的文档都是中文文档，因此强烈建议初字者通读官方文档来了解Vue 的基本使用方法（地址为 https://cn.vuejs.org/v2/guide/),本书后面将直接介绍Vue 在项目中的使用。 Element 简介 Vue 桌面端组件库非常多，比较流行的有 Element、Vux、iView、mint-ui、muse-ui等，本项术用 Element 作为前端页面组件库。要说设计，这些UI库差异都不是很大，基本上都是Materialcsign 风格的，本项目采用 Element 主要考虑到该库的使用人数较多（截至写作本书时，Element的GitHub上的 star数已达 29000,接近30000),出了问题容易找到解决方案。关于Element的，强烈建议初学者通读官方文档学习（地址为http://element-cn.eleme.io/#/zh-CN/component). 其他 除了前端技术点外，后端用到的技术主要就是第1~15 章提到的技术，这里就不详细展开了 章 项目构建 前端项目构建 Vue 项目使用 webpack 来构建。首先确保本地已经安装了 NodeJS,然后在CMD中执行如下 令，可以创建并启动一个名为vuehr的前端项目： npm install -g vue-cli vue init webpack vuehr cd vuehr npm run dev 在执行“vue init webpack vuehr”命令时，会要求依次输入项目的基本信息，如图16-1所示。 Project name vuehr Project description A Vue.js project Author 江南一点雨 基本信息主要包括： 项目名称。 项目描述。 项目作者。 Vue 项目构建：运行＋编译还是仅运行。 是否安装 vue-router. 是否使用 ESLint. 是否使用单元测试。 是否适用 Nightwatch e2e 测试。 是否在项目创建成功后自动执行“npm install”安装依赖，若选择否，则在第4行命令执行之 前执行“npm install”。 当“npm run dev”命令执行之后，在浏览器中输入 http://localhost:8080,显示页面 后端项目构建 后端使用 Spring Boot 创建一个 Spring Boot工程，添加 spring-boot-starter-web 依赖即可： org.springframework.boot spring-boot-starter-web 当然，后端所需的依赖不止spring-boot-starter-web,在后文功能不断完善的过程中，再继续鼎具他依赖。另外，后端项目所需的Redis 配置、邮件发送配置、POI配置、WebSocket配置等将在涉及相关功能时向读者介绍。 数据模型设计 完整的数据库脚本可以在 GitHub 上下载，下载地址为https://github.com/lenve/vhr/blob/master/hrserver/src/main/resources/vhr.sql,这里仅展示本项目的数据字典。 adjustsalary表（员工调薪表） 字段名 逻辑名 数据类型 约束 说明 id Integer 主键，自增长 主键 eid Integer 外键，普通索引 员工id asDate Date 调薪日期 beforeSalary Integer 调前薪资 afterSalary Integer 调后薪资 reason String(255) 调薪原因 remark String(255) 备注 appraise表（员工评价表） 字段名 逻辑名 数据类型 约束 说明 id Integer 主键，自增长 主键 eid Integer 外键，普通索引 员工id appDate Date 考评日期 appResult String(255) 考评结果 appContent String(255) 考评内容 remark String(255) 备注 department表（部门表） 字段名 逻辑名 数据类型 约束 说明 id Integer 主键，自增长 主键 name String(32) 部门名称 parentId Date 父部门id depPath String(255) 部门path enabled Enum 是否可用 isParent Enum 是否为父部门 employee表（员工信息表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 address varchar(64) varchar 64 YES 联系地址 beginContract date date YES 合同起始日期 beginDate date date YES 入职日期 birthday date date YES 出生日期 contractTerm double double YES 合同期限 conversionTime date date YES 转正日期 departmentId int(11) int YES 所属部门 email varchar(20) varchar 20 YES 邮箱 endContract date date YES 合同终止日期 engageForm varchar(8) varchar 8 YES 聘用形式 gender char(4) char 4 YES 性别 id int(11) int NO 员工编号 idCard char(18) char 18 YES 身份证号 jobLevelId int(11) int YES 职称ID name varchar(10) varchar 10 YES 员工姓名 nationId int(8) int YES 民族 nativePlace varchar(20) varchar 20 YES 籍贯 notWorkDate date date YES 离职日期 phone varchar(11) varchar 11 YES 电话号码 politicId int(8) int YES 政治面貌 posId int(11) int YES 职位ID school varchar(32) varchar 32 YES 毕业院校 specialty varchar(32) varchar 32 YES 所属专业 tiptopDegree enum('博士','硕士','本科','大专','高中','初中','小学','其他') enum 2 YES 最高学历 wedlock enum('已婚','未婚','离异') enum 2 YES 婚姻状况 workAge int(11) int YES 工龄 workID char(8) char 8 YES 工号 workState enum('在职','离职') enum 2 YES 在职 在职状态 employeeec表（员工奖励惩罚表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 ecDate date date YES 奖罚日期 ecPoint int(11) int YES 奖罚分 ecReason varchar(255) varchar 255 YES 奖罚原因 ecType int(11) int YES 奖罚类别，0：奖，1：罚 eid int(11) int YES 员工编号 id int(11) int NO remark varchar(255) varchar 255 YES 备注 employeeremove表（员工调岗表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 afterDepId int(11) int YES 调动后部门 afterJobId int(11) int YES 调动后职位 eid int(11) int YES id int(11) int NO reason varchar(255) varchar 255 YES 调动原因 remark varchar(255) varchar 255 YES removeDate date date YES 调动日期 employeetrain表（员工培训表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 eid int(11) int YES 员工编号 id int(11) int NO remark varchar(255) varchar 255 YES 备注 trainContent varchar(255) varchar 255 YES 培训内容 trainDate date date YES 培训日期 empsalary表（员工薪资关联表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 eid int(11) int YES id int(11) int NO sid int(11) int YES hr表 列名 数据类型 字段类型 长度 是否为空 默认值 备注 address varchar(64) varchar 64 YES 联系地址 enabled tinyint(1) tinyint YES 1 id int(11) int NO hrID name varchar(32) varchar 32 YES 姓名 password varchar(255) varchar 255 YES 密码 phone char(11) char 11 YES 手机号码 remark varchar(255) varchar 255 YES telephone varchar(16) varchar 16 YES 住宅电话 userface varchar(255) varchar 255 YES username varchar(255) varchar 255 YES 用户名 hr_role表（hr角色表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 hrid int(11) int YES id int(11) int NO rid int(11) int YES joblevel表（职称表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 createDate timestamp timestamp YES CURRENT_TIMESTAMP enabled tinyint(1) tinyint YES 1 id int(11) int NO name varchar(32) varchar 32 YES 职称名称 titleLevel enum('正高级','副高级','中级','初级','员级') enum 3 YES menu表（菜单表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 component varchar(64) varchar 64 YES enabled tinyint(1) tinyint YES 1 iconCls varchar(64) varchar 64 YES id int(11) int NO keepAlive tinyint(1) tinyint YES name varchar(64) varchar 64 YES parentId int(11) int YES path varchar(64) varchar 64 YES requireAuth tinyint(1) tinyint YES url varchar(64) varchar 64 YES menu_role表（菜单角色关联表） | 列名 | 数据类型 | 字段类型 | 长度 | 是否为空 | 默认值 | 备注 | | ---- | -------- | -------- | ---- | -------- | ------ | ---- | | id | int(11) | int | | NO | | | | mid | int(11) | int | | YES | | | | rid | int(11) | int | | YES | | | msgcontent表（消息内容表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 createDate timestamp timestamp NO CURRENT_TIMESTAMP id int(11) int NO message varchar(255) varchar 255 YES title varchar(64) varchar 64 YES nation表（民族表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 id int(11) int NO name varchar(32) varchar 32 YES oplog表（操作日志表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 addDate date date YES 添加日期 hrid int(11) int YES 操作员ID id int(11) int NO operate varchar(255) varchar 255 YES 操作内容 politicsstatus表（政治面貌表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 id int(11) int NO name varchar(32) varchar 32 YES position表( 职位表) 列名 数据类型 字段类型 长度 是否为空 默认值 备注 createDate timestamp timestamp YES CURRENT_TIMESTAMP enabled tinyint(1) tinyint YES 1 id int(11) int NO name varchar(32) varchar 32 YES 职位 role表（角色表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 id int(11) int NO name varchar(64) varchar 64 YES nameZh varchar(64) varchar 64 YES 角色名称 salary表（薪水表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 accumulationFundBase int(11) int YES 公积金基数 accumulationFundPer float float YES 公积金比率 allSalary int(11) int YES 应发工资 basicSalary int(11) int YES 基本工资 bonus int(11) int YES 奖金 createDate timestamp timestamp YES 启用时间 id int(11) int NO lunchSalary int(11) int YES 午餐补助 medicalBase int(11) int YES 医疗基数 medicalPer float float YES 医疗保险比率 name varchar(32) varchar 32 YES pensionBase int(11) int YES 养老金基数 pensionPer float float YES 养老金比率 trafficSalary int(11) int YES 交通补助 sysmsg表（系统消息表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 hrid int(11) int YES 这条消息是给谁的 id int(11) int NO mid int(11) int YES 消息id state int(11) int YES 0 0 未读 1 已读 type int(11) int YES 0 0表示群发消息 mail_send_log表（邮件发送日志表） 列名 数据类型 字段类型 长度 是否为空 默认值 备注 hrid int(11) int YES 这条消息是给谁的 id int(11) int NO mid int(11) int YES 消息id state int(11) int YES 0 0 未读 1 已读 type int(11) int YES 0 0表示群发消息 经过以上准备工作，项目环境就已经基本搭建成功了。另外，对于Redis的安装、启动等，读者可以参考第6章，这里不再赘述。 登录模块 后端接口实现 后端权限认证采用 Spring Security 实现（本小节中大量知识点与第10章的内容相关，需要读练享握第10章的内容），数据库访问使用MyBatis,同时使用Redis实现认证信息缓存。因此叫自光添加如下依赖（依次是MvBatis 依赖、Spring Security 依赖、Redis 依赖、数据库连接池依赖、数据库驱动依赖以及缓存依赖） org.mybatis.spring.boot >mvbatis-spring-boot-starter 1.3.2 org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-data-redis io.lettuce lettuce-core redis.clients jedis com.alibaba druid 1.1.10 mysql mysql-connector-java org.springframework.boot spring-boot-starter-cache 依赖添加完成后，接下来在 application.properties 中配置数据库连接、Redis连接以及缓存等。 ＃MySQL配置 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.url=jdbc:mysql://127.0.0.1:3306/vhr spring.datasource.username=root spring.datasource.password=root ＃MyBatis日志配置 mybatis.config-location=classpath:/mybatis-config.xml ＃Redis配置 spring.redis.database=0 spring.redis.host=192.168.66.130 spring.redis.port=6379 spring.redis.password=123@456 spring.redis.jedis.pool.max-active=8 spring.redis.jedis.pool.max-idle=8 spring.redis.jedis.pool.max-wait=-1ms spring.redis.jedis.pool.min-idle=0 ＃缓存配置 spring.cache.cache-names=menus cache spring.cache.redis.time-to-live=1800s ＃端口配置 server.port=8082 配置完成后，接下来实现用户认证的配置。用户认证使用Spring Security 实现，因此需要首先 提供一个 UserDetails的实例，在人事管理系统中，登录操作是Hr登录，根据前面的Hr表创建Hr 实体类并实现 UserDetails 接口，代码如下： import com.fasterxml.jackson.annotation.JsonIgnore; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.Objects; public class Hr implements UserDetails { private Integer id; private String name; private String phone; private String telephone; private String address; private Boolean enabled; private String username; private String password; private String userface; private String remark; private List roles; @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Hr hr = (Hr) o; return Objects.equals(username, hr.username); } @Override public int hashCode() { return Objects.hash(username); } public List getRoles() { return roles; } public void setRoles(List roles) { this.roles = roles; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name == null ? null : name.trim(); } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone == null ? null : phone.trim(); } public String getTelephone() { return telephone; } public void setTelephone(String telephone) { this.telephone = telephone == null ? null : telephone.trim(); } public String getAddress() { return address; } public void setAddress(String address) { this.address = address == null ? null : address.trim(); } public void setEnabled(Boolean enabled) { this.enabled = enabled; } public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return enabled; } public void setUsername(String username) { this.username = username == null ? null : username.trim(); } @Override @JsonIgnore public Collection getAuthorities() { List authorities = new ArrayList<>(roles.size()); for (Role role : roles) { authorities.add(new SimpleGrantedAuthority(role.getName())); } return authorities; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password == null ? null : password.trim(); } public String getUserface() { return userface; } public void setUserface(String userface) { this.userface = userface == null ? null : userface.trim(); } public String getRemark() { return remark; } public void setRemark(String remark) { this.remark = remark == null ? null : remark.trim(); } } 代码解释： 自定义类继承自 UserDetails,并实现该接口中相关的方法。前端用户在登录成功后，需要获取当前登录用户的信息，对于一些敏感信息不必返回，使用@JsonIgnore注解即可。 对于 isAccountNonExpired、isAccountNonLocked、isCredentialsNonExpired,由于Hr表并未设计相关字段，因此这里直接返回true,isEnabled方法则根据实际情况返回。 roles 属性中存储了当前用户的所有角色信息，在 getAuthorities 方法中，将这些角色转换为 List的实例返回。 接下来提供一个 UserDetailsService实例用来查询用户，代码如下： @Service public class HrService implements UserDetailsService { @Autowired HrMapper hrMapper; @Autowired HrRoleMapper hrRoleMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Hr hr = hrMapper.loadUserByUsername(username); if (hr == null) { throw new UsernameNotFoundException(\"用户名不存在!\"); } hr.setRoles(hrMapper.getHrRolesById(hr.getId())); return hr; } } 自定义HrService实现 UserDetailsService 接口，并实现该接口中的loadUserByUsemname方法，loadUserBy Username 方法是根据用户名查询用户的所有信息，包括用户的角色，如果没有查到相关用户，就抛出 UsernameNotFoundException 异常，表示用户不存在，如果查到了，就直接返回，由 Spring Security 框架完成密码的比对操作。 接下来需要实现动态配置权限，因此还需要提供 FilterInvocationSecurityMetadataSource 和AccessDecisionManager的实例。 FilterInvocationSecurityMetadataSource 代码如下： @Component public class CustomFilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource { @Autowired MenuService menuService; AntPathMatcher antPathMatcher = new AntPathMatcher(); @Override public Collection getAttributes(Object object) throws IllegalArgumentException { String requestUrl = ((FilterInvocation) object).getRequestUrl(); List menus = menuService.getAllMenusWithRole(); for (Menu menu : menus) { if (antPathMatcher.match(menu.getUrl(), requestUrl)) { List roles = menu.getRoles(); String[] str = new String[roles.size()]; for (int i = 0; i getAllConfigAttributes() { return null; } @Override public boolean supports(Class clazz) { return true; } } 代码解释： 在getAttributes 方法中首先提取出请求 URL,根据请求URL判断该请求需要的角色信息。 通过 MenuService 中的 getAllMenu 方法获取所有的莱单资源进行比对，考虑到getAttributes方法在每一次请求中都会调用，因此可以将 getAllMenu 方法的返回值缓存下来，下一次请求时直接从缓存中获取。 对于所有未匹配成功的请求，默认都是登录后访问。 AccessDecisionManager 代码如： @Component public class UrlAccessDecisionManager implements AccessDecisionManager{ @override public void decide(Authentication auth,Object o,Collectioncas){ Iteratoriterator=cas.iterator(); while (iterator.hasNext()){ ConfigAttribute ca=iterator.next(); String needRole=ca.getAttribute(); if(\"ROLE LOGIN\".equals(needRole)){ if (auth instanceof AnonymousAuthenticationroken){ throw new BadCredentialsException(\"未登录\"); ｝else { return; } } Collection authorities = auth.getAuthorities(); for(GrantedAuthority authority:authorities){ if(authority.getAuthority().equals(needRole)){ return; } ｝ ｝ throw new AccessDeniedException(\"权限不足\"); } @Override public boolean supports(ConfigAttribute configAttribute){ return true; ｝ @Override public boolean supports(ClassaClass){ return true; } } @Component public class CustomUrlDecisionManager implements AccessDecisionManager { @Override public void decide(Authentication authentication, Object object, Collection configAttributes) throws AccessDeniedException, InsufficientAuthenticationException { for (ConfigAttribute configAttribute : configAttributes) { String needRole = configAttribute.getAttribute(); if (\"ROLE_LOGIN\".equals(needRole)) { if (authentication instanceof AnonymousAuthenticationToken) { throw new AccessDeniedException(\"尚未登录，请登录!\"); }else { return; } } Collection authorities = authentication.getAuthorities(); for (GrantedAuthority authority : authorities) { if (authority.getAuthority().equals(needRole)) { return; } } } throw new AccessDeniedException(\"权限不足，请联系管理员!\"); } @Override public boolean supports(ConfigAttribute attribute) { return true; } @Override public boolean supports(Class clazz) { return true; } } 代码解释： 在decide方法中判断当前用户是否具备请求需要的角色，若该方法在执行过程中未抛出异常，则说明请求可以通过；若抛出异常，则说明请求权限不足。 如果所需要的角色是 ROLE LOGIN,那么只需要判断 auth 不是匿名用户的实例，即表示当前用户已登录。 接下来提供一个 AccessDeniedHandler的实例来返回授权失败的信息： @Component public class AuthenticationAccessDeniedHandler implements AccessDeniedHandler{ @Override public void handle(HttpServletRequest httpServletRequest,HttpServletResponse resp,AccessDeniedException e)throws IOException{ resp.setStatus(HttpServletResponse.SC FORBIDDEN); resp.setContentType(\"application/json;charset=UTF-8\"); Printwriter out = resp.getwriter(); RespBean error=RespBean.error(\"权限不足，请联系管理员!\"); out.write(new objectMapper().writeValueAsString(error)); out.flush(); out.close(); } } 当授权失败时，在这里返回授权失败信息。 当所有工作完成后，接下来配置Spring Security 代码如下： @Configuration public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Autowired HrService hrService; @Autowired CustomFilterInvocationSecurityMetadataSource customFilterInvocationSecurityMetadataSource; @Autowired UrlAccessDecisionManager urlAccessDecisionManager; @Autowired AuthenticationAccessDeniedHandler deniedHandler; @override public void configure(WebSecurity web) throws Exception{ web.ignoring().antMatchers(\"/index.html\",\"/static/**\",\"/login_p\"); ｝ @Override protected void configure(HttpSecurity http)throws Exception http.authorizeRequests().withobjectPostProcessor(new AObectPostProcessor)(){ @Override public ＜o extends FilterSecurityInterceptor>O postProcess(O o){ o.setSecurityMetadataSource(metadataSource); o.setAccessDecisionManager(urlAccessDecisionManager); return o; } ｝} o.and().formLogin().loginPage(\"/login p\").loginProcessingUrl(\"/login\").usernameParameter(\"username\").passwordParameter(\"password\").failureHandler(new AuthenticationFailureHandler(){ @Override public void onAuthenticationFailure(HttpServletRequest req,HttpServletResponse resp,AuthenticationException e)throws IOException{ wblugsnresp.setContentType(\"application/json;charset=utf-8\"); RespBean respBean=null; if(e instanceof BadCredentialsException || e instanceof UsernameNotFoundException){ respBean=RespBean.error（\"账户名或者密码输入错误！\"）; ｝else if(e instanceof LockedException){ respBean=RespBean.error(\"账户被锁定，请联系管理员！\"）; ｝else if(e instanceof CredentialsExpiredException){ respBean=RespBean.error(\"密码过期，请联系管理员！”）; ｝else if(e instanceof AccountExpiredException){ respBean=RespBean.error(“账户过期，请联系管理员！\"）; ｝else if(e instanceof DisabledException){o respBean=RespBean.error(”账户被票用，请联系管理员！”）; ｝else { respBean=RespBean.error(“登录失败\"); ｝ resp.setStatus(401); ObjectMapper om=new ObjectMapper(); Printwriter out=resp.getwriter(): out.write(om.writeValueAsString(respBean)); out.flush();eHsdeeoAnons out.close(); } }) .successHandler(new AuthenticationSuccessHandler() @Override public void onAuthenticationSuccess(HttpServletRequest req,HttpServletResponse resp,Authentication auth) throws IOException{ resp.setContentType(\"application/json;charset=utf-8\"); RespBean respBean=RespBean.ok(\"登录成功！”，HrUtils.getCurrentHr()); ObjectMapper om=new ObjectMapper(); PrintWriter out=resp.getwriter(); out.write(om.writeValueAsString(respBean));denoddiw out.flush(); out.close(); } ｝) .permitA1l()oteooAltu).and().logout().permitA1l().land().csrf().disable().exceptionHandling().accessDeniedHandler(deniedHandler); ｝ } 代码解释： 首先通过@EnableGlobalMethodSecurity 注解开启基于注解的安全配置，启用@PreAuthorize和@PostAuthorize两个注解。 在配置类中注入之前创建的4个Bean,在 AuthenticationManagerBuilder 中配置userDetailsService和passwordEncoder. 在 WebSecurity 中配置需要忽略的路径。 在 HttpSecurity 中配置拦截规则、表单登录、登录成功或失败的响应等。 最后通过accessDeniedHandler配置异常处理。 另外，前文提到MenuService 中的 getAllMenu 方法在每次请求时都需要查询数据库，效率极低，因此可以将该数据缓存下来，代码如下： @Service @Transactional @CacheConfig(cacheNames=\"menus_cache\") public class MenuService{ @Autowired MenuMapper menuMapper; @Cacheable(key=\"＃root.methodName\") public ListgetAllMenu(){ return menuMapper.getAllMenu(); } } 注意 这里使用方法名作为缓存的key,另外需要在项目启动类添加@EnableCashing注解开启缓存。 PostMan测试（待写） 前端实现 引入Element和Axios 前端UI使用Element，网络请求则使用Axios， 代码如下： npm i element-ui -S npm i axios -S 依赖添加成功后，接下来在main.js中引入Element 代码如下 import ElementUI from 'element-ui' import 'element-ui/lib/theme-chalk/index.css'; Vue.use(ElementUI) 引入Element 之后，接下来就可以在项目中直接使用相关组件了。 对于网络请求，由于在每一次请求时都需要判断各种异常情况，然后提示用户，例如请求是否成功、失败的原因等，考虑到这些判断基本上都使用重复的代码，因此可以将网络请求封装，做成Vue的插件方便使用。由于封装的代码比较长，这里就不贴出来了，读者可以在GitHub 上查看，地址为 app.js配置完成后，在main.js中导入封装的方法，然后配置为Vue的prototype,代码如下： import {postRequest} from \"./utils/api\"; import {postKeyValueRequest} from \"./utils/api\"; import {putRequest} from \"./utils/api\"; import {deleteRequest} from \"./utils/api\"; import {getRequest} from \"./utils/api\"; import {initMenu} from \"./utils/menus\"; import 'font-awesome/css/font-awesome.min.css' Vue.prototype.postRequest = postRequest; Vue.prototype.postKeyValueRequest = postKeyValueRequest; Vue.prototype.putRequest = putRequest; Vue.prototype.deleteRequest = deleteRequest; Vue.prototype.getRequest = getRequest; 配置完成后，接下来对于任何需要使用网络请求的地址，都可以使用this.XXX执行一个网络请求，例如要执行登录请求，就可以通过this.postRequest(url,param)执行。 开发 Login 页面 接下来在 components 目录下创建 Login.vue 页面进行登录页面开发，代码如下： 系统登录 登录 export default { name: \"Login\", data() { return { loading: false, vcUrl: '/verifyCode?time='+new Date(), loginForm: { username: 'admin', password: '123', code:'' }, checked: true, rules: { username: [{required: true, message: '请输入用户名', trigger: 'blur'}], password: [{required: true, message: '请输入密码', trigger: 'blur'}], code: [{required: true, message: '请输入验证码', trigger: 'blur'}] } } }, methods: { updateVerifyCode() { this.vcUrl = '/verifyCode?time='+new Date(); }, submitLogin() { this.$refs.loginForm.validate((valid) => { if (valid) { this.loading = true; this.postRequest('/doLogin', this.loginForm).then(resp => { this.loading = false; if (resp) { this.$store.commit('INIT_CURRENTHR', resp.obj); window.sessionStorage.setItem(\"user\", JSON.stringify(resp.obj)); let path = this.$route.query.redirect; this.$router.replace((path == '/' || path == undefined) ? '/home' : path); }else{ this.vcUrl = '/verifyCode?time='+new Date(); } }) } else { return false; } }); } } } .loginContainer { border-radius: 15px; background-clip: padding-box; margin: 180px auto; width: 350px; padding: 15px 35px 15px 35px; background: #fff; border: 1px solid #eaeaea; box-shadow: 0 0 25px #cac6c6; } .loginTitle { margin: 15px auto 20px auto; text-align: center; color: #505458; } .loginRemember { text-align: left; margin: 0px 0px 15px 0px; } .el-form-item__content{ display: flex; align-items: center; } 配置路由 import Vue from 'vue' import Router from 'vue-router' import Login from './views/Login.vue' import Home from './views/Home.vue' import FriendChat from './views/chat/FriendChat.vue' import HrInfo from './views/HrInfo.vue' Vue.use(Router) export default new Router({ routes: [ { path: '/', name: 'Login', component: Login, hidden: true }, { path: '/home', name: 'Home', component: Home, hidden: true, meta: { roles: ['admin', 'user'] }, children: [ { path: '/chat', name: '在线聊天', component: FriendChat, hidden: true }, { path: '/hrinfo', name: '个人中心', component: HrInfo, hidden: true } ] }, { path: '*', redirect: '/home' } ] }) 修改去除默认VueLogo 配置请求转发 修改config的index.js文件，修改proxyTable，代码如下： 启动前端项目 npm run dev 动态加载用户菜单 flowchat st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op "},"java16.html":{"url":"java16.html","title":"新蜂商城","keywords":"","body":" 新蜂商城 要点 新蜂商城功能模块和流程设计详解 前端页面设计及技术选型 页面布局制作及跳转逻辑实现 Spring Boot 整合 kaptcha 实现验证码功能 新蜂商城后台管理系统登录功能实现 登陆拦截器设置并完善身份验证 通用分页功能设计与开发实践 技术选型之 Spring Boot JqGrid 插件整合制作分页效果 Spring Boot 实践之文件上传处理及路径回显 新蜂商城轮播图管理模块开发 新蜂商城分类管理模块开发 第一部分的多篇文章已经详细的介绍 Spring Boot 技术栈的相关知识，由 Spring Boot 的基础使用讲到 Spring Boot 的源码解读，包括 Spring Boot 整合 Thymeleaf 制作页面、Spring Boot 整合 MyBatis 操作数据库、Spring Boot 源码分析、Spring Boot 自动配置流程讲解，这些知识点主要是起到过渡的作用，让大家能够有基础的环境搭建能力和 Spring Boot 开发能力。之后是商城系统的开发实战，主要包括商城后台管理系统的开发和商城端的功能开发，在实践过程中我们将整合多个独立的基础功能到一个完整的功能模块中，最终完成各个模块的功能和交互。 按照课程规划，从本篇文章开始，我们就进入项目实战的课程部分，本文我将向朋友们介绍我们接下来要做一个什么样的项目、项目里设计了哪些功能模块以及用户行为与功能模块的关联，介绍完这些之后将在后续的文章中讲解如何一步一步去完成这个项目。 需求确定 在正式进入开发之前，首先我们应该确定开发需求，简单的介绍一下商城系统。 程序员是一个非常务实的群体，这种性格品质用最经典的一句话来概括就是“废话少说，放码过来”，不搞虚头巴脑，是骡子是马拉出来遛遛，而且特别强调项目经验和实战经验。很多开发人员也因此特别注重项目实践，在做项目练习时有很多种类，也会随着个人技术的不断提升而不断变化，最简单的可能是学生管理系统、工资管理系统等等的各种管理系统，之后可能会做一个博客项目或者论坛项目，当然，线上商城系统也是一个不可或缺的一种类型。 什么是商城系统？ 商城系统就是功能完善的网上销售系统，与传统的市场一样，商城系统也会提供交易时所必须的信息交换、支付结算和实物配送这些基础服务，可以让用户通过网络实现购物行为。 像京东、唯品会、天猫这些都是网上商城，这种项目通常包含如下元素： 会员模块 商品模块 订单模块 支付模块 当然，由于系统的完善程度不同，可能还会有仓库模块、物流模块、营销模块等等内容。 网上商城是在为个人用户和企业用户提供人性化的全方位服务，努力为用户创造亲切、轻松和愉悦的购物环境；不断丰富产品结构，最大化地满足消费者日趋多样的购物需求。并凭借更具竞争力的价格和逐渐完善的物流配送体系等各项优势，赢得市场占有率多年稳居行业首位的骄人成绩，也是时代发展的趋势。 为什么要做商城系统？ 热度高 电子商务这些年在国内的高速发展加速了为电子商务服务的软件行业的发展，随之诞生了很多与之密切相关的网店和商城系统。对于网上商城系统的实现技术，无论是开源的亦或者是商业性质的，都非常的丰富，因此商城系统时一个炽手可热的种类，很多开发人员都会尝试着去开发一套线上商城系统。 知识点复杂 商城系统也是一个比较复杂的系统，牵涉的技术内容比较多，而且功能点和技术栈要求也比较高，从零搭建一个商城系统，这个过程不仅考验着开发人员的技术储备丰富度，更考验着技术使用的熟练度，同时对于开发人员的系统设计能力也有要求(系统如何切分，功能点如何设计，页面结构和交互如何优化等)，这些技术栈的掌握程度和项目整体的统筹规划都在一定程度上代表着一个技术人员的能力。 开发和统筹一个完整的大型商城系统往往要求技术人员了解很多不同的技术或者框架，比如常用的前端页面模板和基本的 Web 开发知识、后端开发技术框架(如 Spring Boot 、模板引擎、ORM 框架等)、服务器基础设施(如基础的 shell 命令，Nginx 、 MySQL 等常用软件的搭建和使用)都需进行全局考虑和选择。 产品流程完整 横向来梳理一个商城系统的产品流程，从零到正式上线访问所涉及的项目环节如下，产品设计、原型设计、功能开发、功能测试、产品上线、后期维护等环节缺一不可，开发人员可能不太关注完整的流程，但是能够掌握整个流程的基本脉络对于日后的提升会有极大的帮助。 新蜂商城系统介绍 newbee-mall 项目（中文直译即为新蜂商城）是我发布到开源平台的一套线上商城系统，包括 newbee-mall 商城系统及 newbee-mall-admin 商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发。 前台商城系统包含首页门户、商品分类、新品上线、首页轮播、商品推荐、商品搜索、商品展示、购物车、订单结算、订单流程、个人订单管理、会员中心、帮助中心等模块。 后台管理系统包含数据面板、轮播图管理、商品管理、订单管理、会员管理、分类管理、设置等模块。 该项目包含两个系统： 商城系统 商城后台管理系统 对应的，也包含两种用户体系，一种是商城会员，另一种是商城后台的管理员，在商城系统中，是所有用户都可以浏览使用的系统，商城会员在这里可以浏览、搜索、购买商品并完成购买行为。另一个是商城后台管理系统，管理员在此管理商品信息、订单信息、会员信息等，具体包括商城基本信息的录入和更改、商品信息的添加和编辑、处理订单的拣货和出库，还有商城会员信息的管理。 在小册的开篇词中我已经给出了新蜂商城的页面预览图，这里就简单的看一下好了： 商城首页 商品搜索 订单列表 以上就是最终效果，当然还包括后台管理系统，这里就不占用篇幅了。它就是一个通常意义上的商城项目，该项目包含商城系统的一些共有属性和功能，页面设计以及流程设计也是完全按照商城系统来开发和处理的。 功能详解 大项目虽然复杂，但是也不是完全无法实现，只要我们计划合理、选用的解决方案有效就能够完成这项任务，行业内普遍的一个解决方案就是拆。化繁为简，我们将大项目拆解成若干个小项目，大系统拆分出若干个功能模块，大功能拆解成若干个小功能，之后再对各个环节或者各个功能做具体的实现和完善，比如如何做好功能设计、如何做好接口设计、如何进行表结构设计，具体到功能可能就有如何实现登录功能、如何实现文件上传、如何实现一个分页功能、如何实现分类的三级联动、搜索功能怎样实现、订单流程如何设计等等，当我们将其各个击破并且全部完善的时候，这个完整的项目也就逐渐展现在我们面前。 有些同学可能根据前一篇文章的部署教程已经完成了部署并且体验了大部分功能，为了加深大家的理解并且能够更好的学习该项目，我也把项目中所涉及到的功能点全部列举出来。 商城端功能整理 newbee mall 商城系统所有的功能点列举如下（建议放大图片查看）： 首页 用户进入商城首页后，首先会看到管理员设置的分类信息和轮播图，之后是配置的热销商品等模块，这些数据都是在后台管理系统中配置好的运营数据，在商城端直接读取并且显示到页面即可。 浏览 接下来用户可以选择直接浏览商品信息，也可以根据分类或者关键字去搜索商品，这是用户的浏览行为。 登录和注册 在浏览时我们需要判断用户是否登录，这里就牵涉到商城用户的注册和登录功能了。如果不是商城的注册用户，很多行为是会被限制掉的，此时在商城浏览的用户可以选择填写信息并注册为我们的商城用户，之后就能够登录并且使用商城端的所有功能。 选择商品 登录用户可以在商城网站上任性壕气的浏览、挑选商品，此时就引出了商城的购物车功能，用户可以将商品放到购物车中，可以增加、删除、修改购物车中的商品以及商品数量，这些功能点已经在新蜂商城系统中实现。 提交订单 壕气的用户终于要下手了，在确定了需要购买的商品和数量后，就可以执行提交订单的操作，仅仅选择商品是不行的，我们还需要把用户的收货信息给记录下来。以上这些信息都处理完毕后，就到了订单环节，此时的用户点击结算按钮，我们的系统中也就对应的生成了一笔订单数据。 订单流程 用户在成功的提交订单后，就可以正式的进入到订单操作环节，此时可以选择三个操作： 此时的订单尚未支付，选择去支付流程 下单玩玩，不去管支付流程，继续购物或者退出系统 不想买了或者商品拍错，选择取消订单 以上就是订单模块的流程，包括订单列表功能、订单详情功能、订单取消功能、选择支付方式、支付功能。 确认收货 这是订单流程的最后一个环节，此环节需要商家来配合，用户在支付成功之后订单就进入到商家的管理系统中进行后续的处理，在操作了拣货和配送两个订单状态之后，用户就能够在订单详情页面点击确认收货，此时订单的正向流程就顺利完结了。 因为还有取消订单和关闭订单等操作，所以我们把下单->支付->确认收货这个流程称为正向流程。 后台管理系统功能整理 newbee mall 后台管理系统所有的功能点列举如下（建议放大图片查看）： 后台管理系统中的所有功能模块主要是为了让商城管理员去操作运营数据以及管理用户交易数据，这里通常就是基本的增删改查功能，当然，其中肯定包括商城系统所通用的业务处理逻辑，功能点都在上方的图片中。 轮播图管理 轮播图这种交互方式，在 web 时代似乎已经司空见惯，尤其是购物网站，基本都会留下一定的版面来放置轮播图，后台管理系统中的这个管理模块就是用来添加和编辑轮播图，你在首页看到的轮播图都是在后台配置好的。 商品分类管理 商城中的商品数据繁多，对商品进行分类有利于提供管理效率，同时也能够根据目标用户的需求，用规范的分类数据提高用户的搜索体验，更快更精准的找到需要的商品。后台管理系统中的这个管理模块就是用来添加和编辑分类数据，之后你可以在商品信息中与该数据进行关联，这样就可以在商城端看到商品的分类信息。 热销商品、推荐商品管理 在商城首页可以看到最新的商品列表、热卖商品以及推荐商品，这些商品并不需要搜索，而是优先在首页展现给顾客作为选购时的参考，这些数据也是运营人员在后台管理系统中进行配置，根据实际情况进行这些数据的添加和编辑。 商品管理 商品管理系统是整个电商系统的数据基础，用于记录与商品有关的数据，虽然系统逻辑不复杂，但是由于操作的数据比较多，需要注意很多细节，首页推荐营销、订单模块、支付模块及物流模块都需要从商品中心获取数据。 商品管理模块主要包括商品的内容编辑以及属性的编辑，由于字段较多，该模块的开发也是比较复杂的，因为牵涉到的知识点比较多。 订单管理 订单的生成并不在后台管理系统中实现的，在商城端由用户发起订单流程后，才会在订单管理页面出现对应的订单数据，也只有在用户完成支付后，后台管理员才能够对订单流程的后续操作进行处理，比如出库、发货等等流程。 会员管理 与订单模块类似，会员记录的生成操作也是在商城端来发起的，用户在完成注册之后，数据库中就会出现一条会员记录，信息的编辑也是由用户在个人中心操作的，后台管理系统中只是做了基础的列表和用户状态变更功能。 系统设置 该模块主要是系统管理员信息的处理，包括基本信息的修改功能和密码修改功能。 商城架构整理 商城的技术选型我们介绍完毕，功能点也进行了拆解，这里我简单的整理了一下项目的架构图供大家参考，图片如下（建议放大图片查看）： 主要包括系统的逻辑架构以及实际的基础设施搭建，供大家参考，希望通过这张图片也能让大家得到另外一个层面的思考，不只是使用新蜂商城，也不只是要去弄懂新蜂商城的源码，更要从宏观一些的角度来理解一个项目。 总结 首先介绍了商城系统的相关知识点，让大家更清楚的认识到我们要做的项目以及为什么要做这个项目，紧接着过渡到我们这次的主角--新蜂商城项目，之后结合用户在网页上的行为路径讲解了一下新蜂商城所开发的所有功能点，最后整理了一张简单的系统结构图，希望大家也能够更立体的去看待这个商城项目，我们不仅仅要去拆解它，也要能够看到一个线上项目的脉络结构。文中讲到的更多的其实是功能划分，以及如何看待和理解一个商城系统，也希望大家能够通过我的讲解能够自己搭建和完善一个大型的商城系统。 接下来就是商城系统的开发，再具体一点就是每个功能模块的开发，再具体一点就是每个页面、每个接口的开发，同时也是它们涉及到的每个知识点的讲解，希望通过我的讲解和知识点的拆分，让大家对这个系统的认识能够更加透彻和清晰。虽然这个项目是我开发的，但是这篇文章也花费了我一周的事件去思考和整理，商城项目特性、用户行为记录整理、系统功能点的拆分及图片制作、还有系统架构图的制作，整理这些对于我来说，也是一个重新学习和巩固的过程，有心的朋友也可以按照十三的思路继续去探索和学习， 不仅仅如此，也希望朋友们可以举一反三将知识点扩展开来，以上这些不仅仅是咱们这个商城项目才需要注意的，也可以引申到其他类型的系统，对于系统设计和功能点的拆分、罗列也可以用到其他系统中，能够对自己所做项目的每一个细节、每一个知识点，涉及到的方方面面都有一个较为清晰的认识（当然，也不可能面面俱到，那就尽量做到吧），只有这样才能够在心中构建一个良好的知识体系，以后再碰到问题也就可以迎刃而解了。 视频图解 [x] write some articles "},"moutn10.html":{"url":"moutn10.html","title":"2020年10月账本","keywords":"","body":"10月份目标 [ ] 学习好客租房项目 [ ] 学习app clips [ ] 支付同城对接 2017-07-17 2017-07-17 新增组件 2017-07-18 2017-07-18 新增组件-2 2020年 10月 日 一 二 三 四 五 六 1 * 中秋 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 "},"day23.html":{"url":"day23.html","title":"10月23日","keywords":"","body":"时间跟踪记录 08:02AM 25min 起床 08:27 AM 1h17min 计划 09:45 AM 0h52min 铲屎 10:37 AM 0h4min 出门 10:42 AM 1h00min 骑摩托车 11:43 AM 0h23min 休息 12:06 0h35min 兼职 12:42 0h9min 骑摩托车 12:51 0h3min 走路 12:54 2h27min 吃饭中途去苹果店咨询有没有必要买苹果手表，解决时间跟踪记录的方便性。 经过反复思考与权衡，觉得没有必要。这下心理踏实了。 13:32 0h39min 休息 15:58 0h36min 骑摩托车 16:36 1h34min 走路 18:11 0h43min 骑摩托车 18:54 0h22min 回家 19:17 0h9min 做饭 19:26 4h09min 吃饭吃完饭，开始优化我的nfc标签，调整布局，把常用的优化到位。 晚上还给林小平通电话，探讨风水罗盘，这个花费2个小时。 看b站首次发现手帐这个概念，深入了解手帐需要纸质还是电子好。 发现电子成本很高，于是提出是不是可以用mardown来制作。 这个花费我整整一夜，幸好我没冲动花费230元。发现有两个解决方案 支持todolist和时间轴的markdown文档MrDoc 支持todolist和时间轴的markdown文档gitbook只需要安装2个插件。\"plugins\": [ \"timeline\", \"todo\" ] 第二种方案部署简单，第一种方案太麻烦。。 23:35 4h09min 写博客 2020年10月23日星期五"},"day29.html":{"url":"day29.html","title":"10月29日","keywords":"","body":"Time Ttrack 开发文档 原型设计与思路分析 这里对接FocusTime Trigger API和FocusTime Feed API的文档。处理好逻辑交互。 这里对接FocusTime Trigger API和FocusTime Feed API的文档。处理好逻辑交互。 这里是参数设定与帮助。 ios 快捷指令开发设计 这里用到苹果SiriKit框架 这里对接的是离线时间POST API的文档 参考项目 官网参考工程例子 服务端API说明文档 FocusTime Trigger API的文档 FocusTime Trigger API使您可以在活动设备上启动/结束FocusTime，这是从桌面应用程序手动启动/结束它的替代方法。这对于从第三方应用程序自动化FocusTime很有用。一个示例是在一天中的特定时间开始/结束FocusTime。 服务访问 到达FocusTime触发器API的基本URL为： 对于使用API​​密钥的连接： https://www.rescuetime.com/anapi/start_focustime https://www.rescuetime.com/anapi/end_focustime 必要参数 key #[您的API密钥] duration #一个整数，以分钟为单位表示FocusTime会话的长度，并且必须是5的倍数（ 5、10、15、20 ...）。可以传递-1值来启动FocusTime，直到一天结束。 注意：end_focustime端点不需要此参数。 FocusTime Feed API的文档 FocusTime Feed API是最近触发的开始/结束的FocusTime会话的运行日志。每当新的FocusTime会话开始/结束时，这对于执行第三方应用程序交互非常有用。FocusTime是一项高级功能，因此，对于RescueTime Lite计划的用户， API始终将返回零结果。 服务访问 到达FocusTime Feed API的基本URL是： https://www.rescuetime.com/anapi/focustime_started_feed https://www.rescuetime.com/anapi/focustime_ended_feed 必要参数 key -[您的API密钥] 输出格式 FocusTime Feed API返回一个JSON对象数组，这些数组按相反的时间顺序表示FocusTime的开始/结束事件。每个对象都具有以下结构： { 'id': float (A UNIX timestamp that represents a unique id for the event), 'duration': integer (The initial length of time in minutes for the FocusTime Session, focustime_started_feed only), 'created_at': datetime (The time, in user’s selected time zone, that the session was started) } 查询示例 要请求最近的FocusTime启动事件的列表： https://www.rescuetime.com/anapi/focustime_started_feed?key=YOUR_API_KEY 离线时间POST API的文档 使用离线时间发布API，可以以编程方式发布离线时间，以替代在RescueTime.com上手动输入离线时间。这对于从其他系统捕获信息很有用。例如，在日历应用程序上开会后添加离线时间，或根据位置数据记录行车时间。 服务访问 到达离线时间POST API的基本URL是： 对于使用API​​密钥的连接： https://www.rescuetime.com/anapi/offline_time_post 必需的QUERY参数 key #您的API密钥 start_time #表示脱机时间块开始日期/时间的字符串。该格式应为“ YYYY-MM-DD HH：MM：SS”，但是unix时间戳也是可以接受的。 end_time/duration #表示脱机时间块结束日期/时间的字符串，或者表示脱机时间块持续时间（以分钟为单位）的整数。 activity_name #255个字符或更短的字符串，其中包含将作为活动名称输入的文本（例如，“会议”，“驾驶”，“睡觉”等）。 activity_details #255个字符或更短的字符串，其中包含将作为指定活动的详细信息输入的文本。 输出格式 成功的帖子将以状态码200返回。如果有错误，将返回状态码400。 示例请求 要发布离线时间有关会议刚刚结束： 一个POST请求发送到以下网址： https://www.rescuetime.com/anapi/offline_time_post?key=YOUR_API_KEY JSON主体为： { \"start_time\": \"2020-01-01 09:00:00\", \"duration\": 60, \"activity_name\": \"Meeting\", \"activity_details\": \"Daily Planning\" } "}}